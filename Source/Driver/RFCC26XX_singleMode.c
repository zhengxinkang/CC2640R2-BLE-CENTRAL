/*
* Copyright (c) 2015-2017, Texas Instruments Incorporated
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* *  Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
*
* *  Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* *  Neither the name of Texas Instruments Incorporated nor the names of
*    its contributors may be used to endorse or promote products derived
*    from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <ti/drivers/dpl/ClockP.h>
#include <ti/drivers/dpl/DebugP.h>
#include <ti/drivers/dpl/HwiP.h>
#include <ti/drivers/dpl/SemaphoreP.h>
#include <ti/drivers/dpl/SwiP.h>

#include <ti/drivers/Power.h>
#include <ti/drivers/power/PowerCC26XX.h>
#include <ti/drivers/rf/RF.h>

#include <ti/devices/DeviceFamily.h>
#include DeviceFamily_constructPath(inc/hw_memmap.h)
#include DeviceFamily_constructPath(inc/hw_ints.h)
#include DeviceFamily_constructPath(inc/hw_types.h)
#include DeviceFamily_constructPath(inc/hw_rfc_rat.h)
#include DeviceFamily_constructPath(inc/hw_rfc_dbell.h)
#include DeviceFamily_constructPath(driverlib/rfc.h)
#include DeviceFamily_constructPath(driverlib/sys_ctrl.h)
#include DeviceFamily_constructPath(driverlib/ioc.h)
#include DeviceFamily_constructPath(driverlib/aon_ioc.h)
#include DeviceFamily_constructPath(driverlib/rf_mailbox.h)
#include DeviceFamily_constructPath(driverlib/adi.h)
#include DeviceFamily_constructPath(driverlib/aon_rtc.h)
#include DeviceFamily_constructPath(driverlib/chipinfo.h)

#if defined(__IAR_SYSTEMS_ICC__)
#pragma diag_remark=Pa082
#endif

#if !defined(RF_SINGLEMODE)
#error "A required symbol (RF_SINGLEMODE) is missing."
#endif

/*-------------- Typedefs, structures & defines ---------------*/

/* Definition of internal state-machine events. */
typedef enum RF_FsmEvent_ {
    RF_FsmEventBootDone         = (1<<30),  /* Generated by the RF core at the end of boot sequence. */
    RF_FsmEventPowerStep        = (1<<29),  /* Generated during the power up sequence of RF core. */
    RF_FsmEventLastCommandDone  = (1<<1),   /* Indicates that a radio command is finished. */
    RF_FsmEventWakeup           = (1<<2),   /* Used to initiate the power up sequence of the RF core. */
    RF_FsmEventPowerDown        = (1<<3),   /* Used to initiate the power down sequence of the RF core. */
    RF_FsmEventChangePhy        = (1<<12),  /* Used to initiate a PHY change sequence. */
    RF_FsmEventHwInt            = (1<<13),  /* Generated upon a RAT timer event. */
    RF_FsmEventCpeInt           = (1<<14)   /* Generated during command execution. */
} RF_FsmEvent;

/* Definition of internal power constraints. Note that the physical RAT channels in the RF core are
   not a one-to-one map to the constraint values here. */
typedef enum RF_PowerConstraintSrc_ {
    RF_PowerConstraintRatCh0    = (1 << 0), /* Indicates that the Channel 0 of RAT timer is running. */
    RF_PowerConstraintRatCh1    = (1 << 1), /* Indicates that the Channel 1 of RAT timer is running. */
    RF_PowerConstraintRatCh2    = (1 << 2), /* Indicates that the Channel 2 of RAT timer is running. */
    RF_PowerConstraintCmdQ      = (1 << 3), /* Indicates that the RF core executing a radio command. */
    RF_PowerConstraintDisallow  = (1 << 7)  /* Disable automatic power management. */
} RF_PowerConstraintSrc;

/* Definition of internal Radio Timer (RAT) modes. */
typedef enum RF_RatMode_ {
    RF_RatModeUndefined         = 0,        /* Indicates that the RAT channel is not configured. */
    RF_RatModeCompare           = 1,        /* Indicates that the RAT channel is configured to compare mode. */
    RF_RatModeCapture           = 2         /* Indicates that the RAT channel is configured to capture mode. */
} RF_RatMode;

/* Definition of internal Radio Timer (RAT) states. */
typedef enum RF_RatStatus_ {
    RF_RatStatusIdle            = 0,        /* Indicates that the RAT channel is not used. */
    RF_RatStatusPending         = 1,        /* Indicates that the RAT channel is configured, but the RAT timer is not running (i.e. RF core is OFF). */
    RF_RatStatusRunning         = 2         /* Indicates that the RAT channel is configured, and the RAT timer is running. */
} RF_RatStatus;

/*-------------- Macros ---------------*/

#define ABS(x)     (((x) < 0)   ? -(x) : (x))
#define MAX(x,y)   (((x) > (y)) ?  (x) : (y))
#define MIN(x,y)   (((x) < (y)) ?  (x) : (y))
#define UDIFF(x,y) (((y) > (x)) ? ((y) - (x)) : ((~0) + (y) - (x) + (1)))

/*-------------- Defines ---------------*/

/* Max # of RF driver clients */
#define N_MAX_CLIENTS                          1
/* 8 RF_Cmds in pool */
#define N_CMD_POOL                             8
/* Modulus mask used for RF_CmdHandle calculations */
#define N_CMD_MODMASK                          0xFFF

/*-------------- Internal RF constants ---------------*/

/* Internal RF constants */
#define RF_CMD0                                0x0607
/* Accessible RF Core interrupts mask MSB 32 bits : RFHW int, LSB 32 bits : RF CPE int */
#define RF_INTERNAL_IFG_MASK                   0xFFFFFFDF6000100E
#define RF_CMD_ABORTED_FLAG                    (1 << 0)
#define RF_CMD_STOPPED_FLAG                    (1 << 1)
#define RF_CMD_CANCELLED_FLAG                  (1 << 2)
#define RF_CMD_CANCEL_MASK                     (RF_CMD_ABORTED_FLAG | RF_CMD_STOPPED_FLAG | RF_CMD_CANCELLED_FLAG)
#define RF_CMD_ALLOC_FLAG                      (1 << 7)
#define RF_RUN_CMD_ON_RESTART_FLAG             (1 << 0)
#define RF_RAT_ERR_CB_EVENT_FLAG               (1 << 1)
#define RF_RAT_RPT_CPT_FLAG                    (1 << 2)
#define RF_HW_INT_RAT_CH_MASK                  (RFC_DBELL_RFHWIFG_RATCH7 | RFC_DBELL_RFHWIFG_RATCH6 | RFC_DBELL_RFHWIFG_RATCH5)
#define RF_RAT_CH_CNT                          3
#define RF_HW_INT_CPE_MASK                     RFC_DBELL_RFHWIFG_MDMSOFT
/* Default value for power up duration (in us) used before first power cycle */
#define RF_DEFAULT_POWER_UP_TIME               2500
/* Default minimum power up duration (in us) */
#define RF_DEFAULT_MIN_POWER_UP_TIME           500
/* Default power-up margin (in us) to account for wake-up sequence outside the RF power state machine */
#define RF_DEFAULT_POWER_UP_MARGIN             314
/* Default power down duration in us */
#define RF_DEFAULT_POWER_DOWN_TIME             1000
#define RF_MAX_CHAIN_CMD_LEN                   32
/* RAT channel (0-4) are used by RF Core. Only 5,6,7 are available for application */
#define RF_RAT_CH_LOWEST                       5
#define RF_SEND_RAT_STOP_RATIO                 7
#define RF_RTC_CONV_TO_US_SHIFT                12
#define RF_SHIFT_4_BITS                        4
#define RF_SHIFT_8_BITS                        8
#define RF_SHIFT_16_BITS                       16
#define RF_SHIFT_32_BITS                       32
#define RF_RTC_TICK_INC                        (0x100000000LL/32768)
#define RF_SCALE_RTC_TO_4MHZ                   4000000
#define RF_NUM_RAT_TICKS_IN_1_US               4
/* (3/4)th of a full RAT cycle, in us */
#define RF_DISPATCH_MAX_TIME_US                (UINT32_MAX / RF_NUM_RAT_TICKS_IN_1_US * 3 / 4)
#define RF_DISPATCH_INFINIT_TIME               (UINT32_MAX)
#define RF_INTERNAL_CPE_IFG_MASK_32_BIT        0xFFFFFFFF
#define RF_XOSC_HF_SWITCH_CHECK_PERIOD         50
#define RF_DEFAULT_AVAILRATCH_VAL              0xFFFF
#define RF_ABORT_CANCEL_MULTIPLE_CMD           0x2
#define RF_ABORT_CANCEL_SINGLE_CMD             0x1
#define RF_CMDSTA_REG_VAL_MASK                 0xFF
#define RF_RAT_INTERRUPT_BASE_INDEX            0x01
#define RF_RAT_ERROR_BASE_INDEX                0x10
#define RF_RAT_CPT_CONFIG_RATCH_MASK           0x0F00
#define RF_RAT_CPT_CONFIG_MODE_MASK            0x2000
#define RF_RAT_CPT_CONFIG_REP_MASK             0x1000
#define RF_RAT_COMPENSATION_TIME_US            25
#define RF_PHY_SWITCHING_MODE                  1
#define RF_PHY_BOOTUP_MODE                     0
/* Additional analog config time for setup command */
#define RF_ANALOG_CFG_TIME_US                  96
/* Update analog configuration in setup */
#define RF_SETUP_ANALOGCFG_UPDATE              0
/* Don't update analog configuration in setup */
#define RF_SETUP_ANALOGCFG_NOUPDATE            0x2D
#define RF_DEFAULT_RAT_RTC_ERR_TOL_IN_US       5
/* Approx for 1e6 / 500. XTAL drift is 500 ppm */
#define RF_DEFAULT_COMB_XTAL_DRIFT_BITS_SHIFT  11
/* Window (in us) to decide if wakeup was from RF power up clock */
#define RF_WAKEUP_DETECTION_WINDOW_IN_US       300

/*-------------- Structures ---------------*/

/* RF command queue member */
typedef struct RF_Cmd_s RF_Cmd;

/* RF command member */
struct RF_Cmd_s {
    RF_Cmd* volatile     pNext;   /* Pointer to next #RF_Cmd in queue */
    RF_Callback volatile pCb;     /* Pointer to callback function */
    RF_Op*               pOp;     /* Pointer to (chain of) RF operations(s) */
    RF_Object*           pClient; /* Pointer to client */
    RF_EventMask         bmEvent; /* Enable mask for interrupts from the command */
    RF_EventMask         pastifg; /* Accumulated value of events happened within a command chain */
    uint32_t             rfifg;   /* Return value for callback 0:31 - RF_CPE0_INT, 32:63 - RF_HW_INT */
    RF_CmdHandle         ch;      /* Command handle */
    RF_Priority          ePri;    /* Priority of RF command */
    uint8_t volatile     flags;   /* [0: Aborted, 1: Stopped, 2: cancelled] */
};

/* Rat channel configuration members */
typedef struct RAT_Channel_s RAT_Channel;

/* Rat channel configuration */
struct RAT_Channel_s {
  RF_Handle     pClient;     /* Pointer to current client. NULL means the channel is free. */
  RF_Callback   pCb;         /* Array of callback pointers for each RAT channel. */
  uint32_t      timeout;     /* Timeout for each user defined RAT channel. */
  uint32_t      arg;         /* Arguments to be passed to the immediate command. */
  RF_RatMode    mode;        /* Mode of this RAT channel: RF_RatModeCompare, etc. */
  uint8_t       handle;      /* Channel number: 0,1,2. */
  RF_RatStatus  status;      /* If the channel is allocated. */
};

/* Rat module configuration */
typedef struct RAT_Module_s RAT_Module;

/* Rat module configuration members */
struct RAT_Module_s {
    RAT_Channel             channel[RF_RAT_CH_CNT];  /* Container of channel configurations. */
    uint16_t                availRatCh;              /* Storage of available RAT channels read from the RF core. */
    uint8_t volatile        pendingInt;              /* Pending interrupt flags to be served. */
    uint8_t                 nActiveChannel;          /* Counter of ative channels. This is used to compensate the
                                                        overhead of programming the channels.*/
};

/*-------------- RTOS objects ---------------*/

/* RF core software interrupts */
static SwiP_Struct swiFsm;
static void swiFxnFsm(uintptr_t a, uintptr_t b);

/* RF core hardware interrupts */
static HwiP_Struct hwiCpe0;
static void hwiFxnCpe0PowerFsm(uintptr_t a);
static void hwiFxnCpe0Active(uintptr_t a);

/* RF core HW software interrupts */
static SwiP_Struct swiHw;
static void swiFxnHw(uintptr_t a, uintptr_t b);

/* RF core HW hardware interrupts */
static HwiP_Struct hwiHw;
static void hwiFxnHw(uintptr_t a);

/* Clock used for triggering power-up sequences */
static ClockP_Struct clkPowerUp;
static void clkPowerUpFxn(uintptr_t a);

/* Common inactivity timeout clock callback */
static void clkInactivityFxn(RF_Object* pObj);

/*-------------- Static structures ---------------*/

/* RAT sync/start/stop radio operations */
static union {
    rfc_CMD_SYNC_START_RAT_t start;
    rfc_CMD_SYNC_STOP_RAT_t  stop;
} ratCmd;

/* Default RF parameters structure */
static const RF_Params RF_defaultParams = {
    .nInactivityTimeout     = SemaphoreP_WAIT_FOREVER,
    .nPowerUpDuration       = RF_DEFAULT_POWER_UP_TIME,
    .pPowerCb               = NULL,
    .pErrCb                 = NULL,
    .bPowerUpXOSC           = true,
    .nPowerUpDurationMargin = RF_DEFAULT_POWER_UP_MARGIN,
};

/* Common RF command queue shared by all clients */
static struct {
    RF_Cmd* volatile      pPend;     /* Queue of RF_Cmds pending execution */
    RF_Cmd* volatile      pCurrCmd;  /* RF_Cmd currently executing */
    RF_Cmd* volatile      pCurrCmdCb;/* Holds current command while callback is processed */
    RF_Cmd* volatile      pDone;     /* Queue of RF_Cmds that are done but not retired */
    RF_CmdHandle volatile nSeqPost;  /* Sequence # for previously posted command */
    RF_CmdHandle volatile nSeqDone;  /* Sequence # for last done command */
} cmdQ;

/*-------------- Global variables ---------------*/

/* RF_Cmd container pool. Containers with extra information about RF commands */
static RF_Cmd aCmdPool[N_CMD_POOL];

/* Obj wakeup notification from the Power driver */
static Power_NotifyObj RF_wakeupNotifyObj;

/* Power constraints set by the RF driver */
static volatile uint8_t RF_powerConstraint;

/* Pointer to current radio client (indicates also whether radio powered) */
static RF_Object* pCurrClient;

/* Static container of a direct/immediate commands */
static RAT_Module ratModule;

/* Variables used for powerUpDuration, phySwitchingTime and RAT sync time calculation */
static uint32_t nRtc1;
static uint32_t nRtc3;
static uint32_t activeTimeInUs;
static uint32_t errTolValInUs;

/* Count of radio clients */
static uint8_t nClients;

/*-------------- Externs ---------------*/

/* Hardware attribute structure populated in board.c file to set HWI and SWI priorities */
extern const RFCC26XX_HWAttrs RFCC26XX_hwAttrs;

/*-------------- Booleans ---------------*/

/* Initialize available RAT channels */
static bool bRatSyncWasRequested;

/* Indicates the first instance the radio power up/down is done after rf_init() */
static bool bRadioHasBeenBootedBefore;

/* Powerup requested when powering down */
static bool volatile bRadioRestartIsRequested;

/* Keeps track of whether radio is active */
static bool bRadioIsActive;

/* Indicate when Radio is in power-up FSM */
static bool bRadioIsBeingPoweredUp;

/* Indicate when Radio is in power-down FSM */
static bool bRadioIsBeingPoweredDown;

/* Indicate if RF_yield requested to power-down the RF Core */
static bool bRadioYieldingWasRequested;

/* Indicate request to cancel a power-down request from RF_yield */
static bool bRadioYieldWasCancelled;

/* Variable to indicate if the XOSC_HF_SWITCHING is done by the RF Driver */
static bool bRadioDelegateXOSCHFSwitching;

/* variable to indicate with the FLASH is disable during the power up */
static bool bDisableFlashInIdleConstraint;

/*-------------- State machine functions ---------------*/

/* FSM typedefs */
typedef void (*Fsm_StateFxn)(RF_Object*, RF_FsmEvent const);

/* Current state of radio state-machine */
static Fsm_StateFxn pFsmState;

/* FSM helper functions */
static void FsmNextState(Fsm_StateFxn pTarget);

/* FSM state functions */
static void fsmPowerUpState(RF_Object *pObj, RF_FsmEvent e);
static void fsmSetupState(RF_Object *pObj, RF_FsmEvent e);
static void fsmActiveState(RF_Object *pObj, RF_FsmEvent e);
static void fsmXOSCState(RF_Object *pObj, RF_FsmEvent e);

/*-------------- Helper functions ---------------*/

/* Command queue handling */
static RF_Cmd*      Q_peek(RF_Cmd* volatile* ppHead);
static RF_Cmd*      Q_pop(RF_Cmd* volatile* ppHead);
static bool         Q_push(RF_Cmd* volatile* ppHead, RF_Cmd* pCmd, bool* bHeadPos);
static RF_Cmd*      Q_end(RF_Handle h, RF_Cmd* volatile* ppHead);

/* Command handling*/
static RF_Cmd*      allocCmd(void);
static RF_Cmd*      getCmd(RF_CmdHandle ch, uint8_t mask);

/* RAT module */
static RAT_Channel* ratGetChannel(uint8_t ch);
static RAT_Channel* ratAllocChannel(void);
static void         ratRestartChannels();
static RF_Stat      ratArmChannel(RAT_Channel* ratCh);
static void         ratFreeChannel(RAT_Channel* ratCh);
static void         ratSuspendChannels(void);
static bool         ratReleaseChannels(void);
static bool         ratDispatchTime(uint32_t* dispatchTimeClockTicks);

/* Time management */
static uint32_t     calculateDeltaTimeUs(uint32_t absTime, uint32_t nPowerUpDuration);
static bool         cmdDispatchTime(uint32_t* dispatchTimeClockTicks);
static bool         calculateDispatchTime(uint32_t* dispatchTimeClockTicks);
static void         triggDispatcher(void);
static void         dispatchNextEvent(void);
static void         dispatchNextCmd(void);
static void         restartClockTimeout(ClockP_Handle clockHandle, uint32_t timeoutClockTicks);

/* Power management */
void                rfReleaseConstraint(RF_PowerConstraintSrc src);
void                rfSetConstraint(RF_PowerConstraintSrc src);

/* Others */
static void         defaultCallback(RF_Handle h, RF_CmdHandle ch, RF_EventMask e);
static RF_Stat      runDirectImmediateCmd(RF_Handle h, uint32_t pCmd, uint32_t* rawStatus);
static RF_Stat      executeDirectImmediateCmd(uint32_t pCmd, uint32_t* rawStatus);

/*-------------- Command queue internal functions ---------------*/

/*
 *  Peek at first entry in simple queue.
 *
 *  Input:  ppHead - Pointer to the head of the command queue
 *  Return: RF command
 */
static RF_Cmd* Q_peek(RF_Cmd* volatile* ppHead)
{
    return (RF_Cmd*)*ppHead;
}

/*
 *  Pop first entry in simple queue.
 *
 *  Input:  ppHead - Pointer to the head of the command queue
 *  Return: RF command
 */
static RF_Cmd* Q_pop(RF_Cmd* volatile* ppHead)
{
    RF_Cmd* pCmd;
    uint32_t key = HwiP_disable();
    if ((pCmd=(RF_Cmd*)*ppHead))
    {
        *ppHead = (RF_Cmd*)pCmd->pNext;
    }
    HwiP_restore(key);
    return pCmd;
}

/*
 *  Push entry onto simple queue.
 *
 *  Input:  h        - RF handle
 *          ppHead   - Pointer to the head of the command queue
 *          pCmd     - Pointer to command
 *          bHeadPos - Boolean to indicate if this was the first command in the queue
 *  Return: true     - If command was pushed to the queue.
 *          false    - If command was rejected.
 */
static bool Q_push(RF_Cmd* volatile* ppHead, RF_Cmd* pCmd, bool* bHeadPos)
{
    uint32_t key;

    /* Start at the head of queue */
    RF_Cmd* pEnd = (RF_Cmd*)*ppHead;

    /* Set the next to be null*/
    pCmd->pNext = NULL;

    /* If the queue is empty */
    if (pEnd == NULL)
    {
        /* Enter critical section */
        key = HwiP_disable();

        /* First entry into queue */
        *ppHead = pCmd;

        /* Indicate that it is the first entry */
        if(bHeadPos)
        {
          *bHeadPos = true;
        }
    }
    else
    {
        /* Indicate that this is not the first entry*/
        if(bHeadPos)
        {
          *bHeadPos = false;
        }

        /* Enter critical section */
        key = HwiP_disable();

        /* Find the tail */
        while (pEnd->pNext)
        {
            pEnd = (RF_Cmd*)pEnd->pNext;
        }

        /* Sanity check - to avoid pEnd->pNext pointing to self */
        if (pEnd == pCmd)
        {
            HwiP_restore(key);
            return false;
        }

        /* Append the command */
        pEnd->pNext = pCmd;
    }

    /* Exit critical section */
    HwiP_restore(key);

    /* Return with success */
    return true;
}

/*
 *  Search last entry in simple queue for particular client.
 *
 *  Input:  h      - RF handle
 *          ppHead - Pointer to the head of the command queue
 *  Return: RF command
 */
static RF_Cmd* Q_end(RF_Handle h, RF_Cmd* volatile* ppHead)
{
    /* Local variables */
    RF_Cmd* pEnd       = NULL;
    RF_Cmd* pClientEnd = NULL;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* If there is at least one entry in the queue */
    if ((pEnd = (RF_Cmd*)*ppHead))
    {
        /* Set the pointer to store its location */
        pClientEnd = pEnd;

        /* Step the queue */
        while (pEnd->pNext)
        {
            pEnd = (RF_Cmd*)pEnd->pNext;
            pClientEnd = pEnd;
        }
    }

    /* Exit critical section */
    HwiP_restore(key);

    /* Return with the last entry belongs to the client */
    return pClientEnd;
}

/*
 *  Allocate a command buffer from the command pool.
 *
 *  Input:  none
 *  Return: RF command
 */
static RF_Cmd* allocCmd(void)
{
    uint32_t i;
    for (i = 0; i < N_CMD_POOL; i++)
    {
        /* Find the first available entry in the command pool */
        if (!(aCmdPool[i].flags & RF_CMD_ALLOC_FLAG))
        {
            return &aCmdPool[i];
        }
    }
    return NULL;
}

/*
 *  Search for a command in the command pool.
 *
 *  Input:  ch - RF command handle
 *  Return: RF command
 */
static RF_Cmd* getCmd(RF_CmdHandle ch, uint8_t mask)
{
    uint32_t i;
    for (i = 0; i < N_CMD_POOL; i++)
    {
        /* Find the allocated command pool entry corresponding to ch */
        if (aCmdPool[i].ch == ch)
        {
            /* If a mask is provided, check the flags too */
            if(!mask || (aCmdPool[i].flags & mask))
            {
                return &aCmdPool[i];
            }
        }
    }

    return NULL;
}

/*
 *  Reconfigure and restart a particular clock object.
 *
 *  Input:  clockObj          - A pointer to a clock object.
 *          timeoutClockTicks - The timeout to be set in unit of clock ticks.
 *  Return: none
 */
static void restartClockTimeout(ClockP_Handle clockHandle, uint32_t timeoutClockTicks)
{
    ClockP_setTimeout(clockHandle, timeoutClockTicks);
    ClockP_start(clockHandle);
}

/*
 *  Calculate the delta time to an RF event including the overhead of powering up
 *  and down.
 *
 *  Input:  abstime          - The timestamp the event will need to happen.
 *          nPowerUpDuration - The duration we need to compensate with.
 *  Return: deltaTime        - The time left until the RF core need to be trigged.
 */
static uint32_t calculateDeltaTimeUs(uint32_t absTime, uint32_t nPowerUpDuration)
{
    /* Local variables. */
    uint32_t deltaTimeUs;

    /* Read the timestamp to calculate difference from. */
    uint32_t currentTime = RF_getCurrentTime();

    /* Calculate the difference with the current timestamp. */
    deltaTimeUs  = UDIFF(currentTime, absTime);
    deltaTimeUs /= RF_NUM_RAT_TICKS_IN_1_US;

    /* Check if delta time is greater than (powerup duration + power down duration) for a
       power cycle, and is less than 3/4 of a RAT cycle (~17 minutes) */
    if ((deltaTimeUs > (int32_t)(nPowerUpDuration + RF_DEFAULT_POWER_DOWN_TIME)) &&
        (deltaTimeUs <= RF_DISPATCH_MAX_TIME_US))
    {
        /* Dispatch command in the future */
        return MAX((deltaTimeUs - nPowerUpDuration), 1);
    }
    else
    {
        /* Dispatch immediately */
        return 0;
    }
}

/*
 *  Calculate the wakeup time of next command in the queue.
 *
 *  Input:  dispatchTimeClockTicks - Location where the calculated time is being stored.
 *  Return: validTime              - Indicates if the returned time is valid.
 */
static bool cmdDispatchTime(uint32_t* dispatchTimeClockTicks)
{
    /* By default, there is no command in the queue. */
    bool validTime = false;

    /* The next command in the queue determines the timing. */
    RF_Cmd* pCmd = cmdQ.pPend;

    /* Only recognizes TRIG_ABSTIME triggers, everything else gets dispatched immediately. */
    if (pCmd)
    {
        /* If there is at least one pending command, we can calculate a legit dispatch time. */
        validTime = true;

        if(pCmd->pOp->startTrigger.triggerType == TRIG_ABSTIME)
        {
            /* Calculate the remained time until this absolute event. The calculation takes
               into account the minimum power cycle time. */
            *dispatchTimeClockTicks = calculateDeltaTimeUs(pCmd->pOp->startTime,
                                                           pCmd->pClient->clientConfig.nPowerUpDuration +
                                                           (RF_RAT_COMPENSATION_TIME_US * ratModule.nActiveChannel));

            /* Scale the value to clock ticks*/
            *dispatchTimeClockTicks /= ClockP_tickPeriod;
        }
        else
        {
            /* Dispatch immediately. */
            *dispatchTimeClockTicks  = 0;
        }
    }
    else
    {
        /* This value will not be used. */
        *dispatchTimeClockTicks  = 0;
    }

    /* If the returned timestamp represents a valid dispatch time, return with true. */
    return validTime;
}

/*
 *  Allocate a RAT channel from the three slots available
 *  for the user.
 *
 *  Input:  none
 *  Return: Pointer to a container in ratModule - If success.
 *          NULL                                - If failure.
 */
static RAT_Channel* ratAllocChannel(void)
{
    /* Walk the RAT channel indexes. */
    uint32_t i;
    for (i = 0; i < RF_RAT_CH_CNT; i++)
    {
        /* Calculate the bit representing this channel within the available channels. */
        uint32_t bitMask = (1 << i);

        /* Verify that no one is using this channel (from outside the scope of RF driver). */
        if(ratModule.availRatCh & bitMask)
        {
            /* Decode the fields of a channel. */
            RAT_Channel* ratCh = ratGetChannel(i);

            /* If an available channel is found. */
            if (ratCh && (ratCh->status == RF_RatStatusIdle))
            {
                /* Mark the channel as occupied. */
                ratModule.availRatCh &= ~bitMask;

                /* Put the channel into pending state. */
                ratCh->status = RF_RatStatusPending;
                ratCh->handle = i;

                /* Increment the counter of active channels. This is used to compensate the
                   power up time with the overhead of programming these channels. */
                ratModule.nActiveChannel += 1;

                /* Return with a pointer to the channel. */
                return ratCh;
            }
        }
    }

    /* Return with an invalid channel pointer in case of error. */
    return NULL;
}

/*
 *  Populate a given RAT channel container.
 *
 *  Input:  ratCh   - Pointer to a RAT channel in ratModule to be populated.
 *          pClient - Pointer to an RF client.
 *          pCb     - Pointer to the callback function to be registered to this RAT channel.
 *          timeout - timeout value in case of compare mode, 0 in case of capture.
 *          mode    - Indicating the RAT mode the channel is being configured to.
 *          arg     - Storing the command to be passed to the RF core doorbell.
 *  Return: none
 */
static void ratConfigureChannel(RAT_Channel* ratCh, RF_Handle pClient, RF_Callback pCb, uint32_t timeout, RF_RatMode mode, uint32_t arg)
{
    ratCh->pClient = pClient;
    ratCh->pCb     = pCb;
    ratCh->timeout = timeout;
    ratCh->mode    = mode;
    ratCh->arg     = arg;
}

/*
 *  Free a given RAT channel.
 *
 *  Input:  ratCh - Pointer to a RAT channel in ratModule.
 *  Return: none
 */
static void ratFreeChannel(RAT_Channel* ratCh)
{
    /* Enter critical section */
    uint32_t key = HwiP_disable();

    if(ratCh)
    {
        /* By default, do not release the constraint on this RAT channel. */
        RF_PowerConstraintSrc powerConstraint = (RF_PowerConstraintSrc)(1 << ratCh->handle);

        /* If the RF core power domain is ON. */
        if(HWREG(PRCM_BASE+PRCM_O_PDSTAT0) & 1)
        {
            /* Disable the RAT channel interrupt source. */
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFHWIEN) &= ~(1 << (RFC_DBELL_RFHWIFG_RATCH5_BITN + ratCh->handle));
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFHWIFG) &= ~(1 << (RFC_DBELL_RFHWIFG_RATCH5_BITN + ratCh->handle));
        }

        /* Reset the status of the channel. */
        ratCh->status = RF_RatStatusIdle;

        /* Mark the channel as available. */
        ratModule.availRatCh |= (1 << ratCh->handle);

        /* Reset the content of the container. */
        ratConfigureChannel(ratCh, NULL, NULL, 0, RF_RatModeUndefined, 0);

        /* Decrement the counter of active channels. */
        ratModule.nActiveChannel -= 1;

        /* Notify the state machine that the RF core can be possibly powered down. */
        rfReleaseConstraint(powerConstraint);
    }

    /* Exit critical section */
    HwiP_restore(key);
}

/*
 *  Returns with a pointer to a RAT channel based on it's handle.
 *
 *  Input:  ch    - Channel handle.
 *  Return: ratCh - Pointer to a RAT channel in ratModule.
 */
static RAT_Channel* ratGetChannel(uint8_t ch)
{
    /* Convert a valid index into a pointer of a RAT channel configuration. */
    if(ch < RF_RAT_CH_CNT)
    {
        return (RAT_Channel*)&ratModule.channel[ch];
    }

    /* Return with NULL in case of invalid input argument. */
    return NULL;
}

/*
 *  Suspend the running channels and potentially initiate a power down.
 *
 *  Input:  none
 *  Return: true  - All RAT channel is suspended.
 *          false - Otherwise.
 */
static bool ratReleaseChannels(void)
{
    /* If there is pending interrupt, wait until it is served. */
    if(!ratModule.pendingInt)
    {
        /* Calculate if there is enough time to power down and up. */
        uint32_t dispatchTimeClockTicks;
        bool validTime = ratDispatchTime(&dispatchTimeClockTicks);

        /* If the next event is sufficiently far into the future. */
        if(validTime && dispatchTimeClockTicks)
        {
            /* Suspend all RAT channels. */
            ratSuspendChannels();

            /* Indicate that the device can be powered down. */
            return true;
        }
    }

    /* We cannot pwoer down right now. */
    return false;
}

/*
 *  Calculate the timeout of closest RAT event.
 *
 *  Input:  dispatchTimeClockTicks - Location where the calculated time is being stored.
 *  Return: validTime              - Indicates if the returned time is valid.
 */
static bool ratDispatchTime(uint32_t* dispatchTimeClockTicks)
{
    /* By default, there is no RAT running. */
    bool validTime = false;

    /* Initialize the return value. */
    *dispatchTimeClockTicks = RF_DISPATCH_INFINIT_TIME;

    /* Iterate through the RAT containers and calculate the remained time until
       the closest RAT event. */
    uint32_t i;
    for(i = 0; i < RF_RAT_CH_CNT; i++)
    {
        /* Use a local pointer to have easier access to member fields. */
        RAT_Channel* ratCh = ratGetChannel(i);

        /* If the channel is either in PENDING or RUNNING state, meaning it is in use. */
        if(ratCh && ratCh->status)
        {
            /* There is at least one active channel, we can calculate a legit timestamp. */
            validTime = true;

            /* If there is at least one channel in Capture mode, we need to power
               up immediately. */
            if(ratCh->mode == RF_RatModeCapture)
            {
                /* Use immediate timeout. */
                *dispatchTimeClockTicks = 0;

                /* No point to look to the other RAT channels.*/
                break;
            }
            else
            {
                /* Calculate the remained time until this RAT event. The calculation takes
                   into account the minimum power cycle time. */
                uint32_t deltaTimeUs = calculateDeltaTimeUs(ratCh->timeout,
                                                            pCurrClient->clientConfig.nPowerUpDuration +
                                                            (RF_RAT_COMPENSATION_TIME_US * ratModule.nActiveChannel));

                /* Scale the value to clock ticks. */
                deltaTimeUs /= ClockP_tickPeriod;

                /* If this is the closest RAT event, update the timer. */
                if(deltaTimeUs < (*dispatchTimeClockTicks)) *dispatchTimeClockTicks = deltaTimeUs;

            }
        }
    }

    /* Return with true if the dispatchTime represents a valid timestamp. */
    return validTime;
}

/*
 *  Arms a given RAT channel. The mode of the channel will define which mode
 *  it is being configured to. The arg variable contains the command to be
 *  sent to the RF core.
 *
 *  Input:  ratCh  - Pointer to a RAT channel.
 *  Return: status - Status code based on the response of RF core.
 *
 */
static RF_Stat ratArmChannel(RAT_Channel* ratCh)
{
    /* Local variable */
    RF_Stat status = RF_StatError;

    if(ratCh && (ratCh->status == RF_RatStatusPending))
    {
        /* Enable the interrupt source for that particular channel. */
        HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFHWIFG) &= ~(1 << ((RFC_DBELL_RFHWIFG_RATCH5_BITN + ratCh->handle)));
        HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFHWIEN) |=  (1 << ((RFC_DBELL_RFHWIFG_RATCH5_BITN + ratCh->handle)));

        /* Set the power constraint on this channel to keep the RF core ON. */
        rfSetConstraint((RF_PowerConstraintSrc)(1 << ratCh->handle));

        /* Send the command to the RF core. */
        status = executeDirectImmediateCmd(ratCh->arg, NULL);

        /* Put the command into running state. */
        if(status == RF_StatCmdDoneSuccess)
        {
            ratCh->status = RF_RatStatusRunning;
        }
    }

    /* Return with the status code. */
    return status;
}

/*
 *  Restarts any RAT channels which are in pending state at the moment of
 *  invoking this method. This is used to automatically restore the rat module
 *  right after the RF core is powered up. This is essential for power management.
 *
 *  Input:  none
 *  Return: none
 *
 */
static void ratRestartChannels(void)
{
    /* Iterate through the RAT containers and restore the channels
       which were in running state before we entered Standby mode. */
    uint32_t i;
    for(i = 0; i < RF_RAT_CH_CNT; i++)
    {
        RAT_Channel* ratCh = ratGetChannel(i);

        if(ratCh && (ratCh->status == RF_RatStatusPending))
        {
            /* Try to program the RAT channel. */
            RF_Stat status = ratArmChannel(ratCh);

            /* Execute error handling if programming fails, i.e. due to past timestamp.
               This is done in SWI context. */
            if(status != RF_StatCmdDoneSuccess)
            {
                /* Mark the event as an error by setting also a shadow bit. */
                ratModule.pendingInt |= ((RF_RAT_INTERRUPT_BASE_INDEX | RF_RAT_ERROR_BASE_INDEX) << ratCh->handle);

                /* Post the SWI handler to serve the callback. */
                SwiP_or(&swiHw, 0);
            }
        }
    }
}

/*
 *  Suspends any RAT channel which are in RUNNING state.
 *  This is used to force all RAT channels into pending state allowing the power
 *  management to power off the RF core power domain and resynchronize the RAT channels
 *  on next power up.
 *
 *  Input:  none
 *  Return: none
 */
static void ratSuspendChannels(void)
{
    /* Iterate through the RAT containers and suspend the active channels. */
    uint32_t i;
    for(i = 0; i < RF_RAT_CH_CNT; i++)
    {
        /* Set a pointer to the channel. */
        RAT_Channel* ratCh = ratGetChannel(i);

        /* Only actively running channles can be suspended. */
        if(ratCh && (ratCh->status == RF_RatStatusRunning))
        {
            /* Set the status to be suspended. */
            ratCh->status = RF_RatStatusPending;
        }
    }
}

/*
 *  Generate a command which can be used to configure a RAT channel into COMPARE mode.
 *
 *  Input:  ratHandle   - Handle to a RAT channel which is being configured to compare mode. The handle is used
 *                        within the command itself to select the proper channel in the RF core (channel 5-6-7).
 *          pCmd        - Pointer to a command structure to be populated and passed to the RF core when the RAT
 *                        channel is programmed.
 *          compareTime - The compare timeout when the compare event should occur.
 *  Return: pCmd        - Return with the address of the command structure. It is casted to uint32_t as it is
 *                        stored in a generic variable.
 */
static uint32_t ratGenerateCompareCmd(RF_RatHandle ratHandle, rfc_CMD_SET_RAT_CMP_t* pCmd, uint32_t compareTime)
{
    /* Populate the user provided command structure properly. */
    pCmd->ratCh       = RF_RAT_CH_LOWEST + ratHandle;
    pCmd->commandNo   = CMD_SET_RAT_CMP;
    pCmd->compareTime = compareTime;

    /* Return with a pointer to the structure. */
    return (uint32_t)pCmd;
}

/*
 *  Generate a command which can be used to configure a RAT channel into CAPTURE mode.
 *
 *  Input:  ratHandle   - Handle to a RAT channel which is being configured to capture mode. The handle is used
 *                        within the command itself to select the proper channel in the RF core (channel 5-6-7).
 *          config      - Bitwise configuration field of the capture command sent to the RF core.
 *  Return: command     - Return with the direct command to be sent to the RF core when the RAT channel is
 *                        programmed. It is casted to uint32_t as it is stored in a generic variable.
 */
static uint32_t ratGenerateCaptureCmd(RF_RatHandle ratHandle, uint16_t config)
{
    /* Calculat the direct command to be sent to the RF core.*/
    config  = config & ~(RF_RAT_CPT_CONFIG_RATCH_MASK | RF_RAT_CPT_CONFIG_MODE_MASK);
    config |= (((RF_RAT_CH_LOWEST + ratHandle) << RF_SHIFT_8_BITS) & RF_RAT_CPT_CONFIG_RATCH_MASK);
    config |= RF_RAT_CPT_CONFIG_MODE_MASK;

    /* Generate the direct command based on the configuration. */
    return (uint32_t)CMDR_DIR_CMD_2BYTE(CMD_SET_RAT_CPT, config);
}

/*
 *  Wrapper function to setup a RAT channel into the selected mode.
 *
 *  Input:  h           - Handle previously returned by RF_open().
 *          pCb         - Callback function to be registered to the RAT channel.
 *          pCmd        - Pointer to command structure to be used in case of compare mode.
 *          compareTime - Absolute compare time to be used in case of compare mode.
 *          config      - Bitwise configuration to be used to generate a command for capture mode.
 *          ratMode     - Identifies the mode the channel is being set up: RF_RatModeCompare or RF_RatModeCapture.
 *  Return: ratHandle   - RF_RatHandle to the allocated channel. If allocation fails, RF_ALLOC_ERROR is returned.
 */
static RF_RatHandle ratSetupChannel(RF_Handle h, RF_Callback pCb, rfc_CMD_SET_RAT_CMP_t* pCmd, uint32_t compareTime, uint16_t config, RF_RatMode ratMode)
{
    /* Return with an error. Either we couldn't allocate any RAT
       channel, or the RAT module declined our configuration. */
    RF_RatHandle ratHandle = (RF_RatHandle)RF_ALLOC_ERROR;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Find and allocate a RAT channel (if any is available) */
    RAT_Channel* ratCh = ratAllocChannel();

    /* If we could allocate a RAT channel */
    if (ratCh)
    {
        /* Argument to store the mode speific command temporarily. This function is always called with a valid
           mode and thus the default branch will not be used. */
        uint32_t arg;

        /* Prepare the command based on the method we use. */
        switch(ratMode)
        {
            case(RF_RatModeCompare): arg = ratGenerateCompareCmd(ratCh->handle, pCmd, compareTime);
                                     break;

            case(RF_RatModeCapture): arg = ratGenerateCaptureCmd(ratCh->handle, config);
                                     break;

            default:                 arg = 0;
                                     break;
        }

        /* Use the default "do nothing" callback if it is not provided by the user. */
        if(!pCb) pCb = (RF_Callback)defaultCallback;

        /* Populate the container. */
        ratConfigureChannel(ratCh, h, pCb, compareTime, ratMode, arg);

        /* Decide which PHY should be used upon start up. */
        if(pCurrClient == NULL)
        {
            pCurrClient = ratCh->pClient;
        }

        /* Calculate the RAT/RTC timestamp to be used to wake the RF core. */
        dispatchNextEvent();

        /* Return with a handle upon success. */
        ratHandle = (RF_RatHandle)ratCh->handle;
    }

    /* Exit critical section. */
    HwiP_restore(key);

    /* Return with either an Error OR a handle to a RAT channel. */
    return ratHandle;
}

/*
 *  Wake up notification callback from the power driver. If the callback is from RF wakeup
 *  set constraint to let RF Driver control the XOSC switching else do nothing in the
 *  callback.
 *
 *  Input:  eventType - The type of event when the notification is invoked
 *          eventArg  - Not used.
 *          clientArg - Not used.
 *  Return: Power_NOTIFYDONE
 */
static uint8_t RF_wakeupNotifyFxn(uint8_t eventType, uint32_t *eventArg, uint32_t *clientArg)
{
    /* Check if the callback is for wakeup from standby and if power up clock is running */
    if ((eventType == PowerCC26XX_AWAKE_STANDBY) && (ClockP_isActive(&clkPowerUp)))
    {
        /* Calculate time (in us) until next trigger (assume next trigger is max ~70 min away) */
        uint32_t timeInUsUntilNextTrig = ClockP_tickPeriod * ClockP_getTimeout(&clkPowerUp);

        /* Check if the next trig time is close enough to the actual power up */
        if (timeInUsUntilNextTrig < RF_WAKEUP_DETECTION_WINDOW_IN_US)
        {
            /* Stop power up clock */
            ClockP_stop(&clkPowerUp);

            /* Setup RF Driver to do the XOSC_HF switching */
            Power_setConstraint(PowerCC26XX_SWITCH_XOSC_HF_MANUALLY);

            /* Set variable to indicate RF Driver will do the XOSC_HF switching */
            bRadioDelegateXOSCHFSwitching = true;

            /* Start the RF Core power up */
            SwiP_or(&swiFsm, RF_FsmEventWakeup);
        }
    }

    return Power_NOTIFYDONE;
}

/*
 *  Execute RF power down sequence.
 *
 *  Input:  none
 *  Return: none
 */
static void powerDownRfCore(void)
{
    /* Set VCOLDO reference */
    RFCAdi3VcoLdoVoltageMode(false);

    /* Remap HWI to the startup function (preparing for next wake up) */
    HwiP_setFunc(&hwiCpe0, hwiFxnCpe0PowerFsm, (uintptr_t)NULL);

    /* Take wake up timestamp and the current timestamp */
    nRtc3 = (uint32_t) AONRTCCurrent64BitValueGet();

    /* Find the radio core active time since the last power up */
    activeTimeInUs  += UDIFF(nRtc1, nRtc3);
    activeTimeInUs >>= RF_RTC_CONV_TO_US_SHIFT;

    /* Decide whether to send the CMD_SYNC_STOP_RAT command. If this is first power down (bStart is false), active time
       is longer than the time that can cause max allowed error between RAT and RTC clocks or if RF_yield was called
       (bRatSync is true) */
    if ((bRadioHasBeenBootedBefore == false) ||
        (bRatSyncWasRequested      == true)  ||
        (activeTimeInUs > (errTolValInUs << RF_DEFAULT_COMB_XTAL_DRIFT_BITS_SHIFT)))
    {
        /* Mark that we handled it */
        bRadioHasBeenBootedBefore = true;

        /* Clear any request for RAT sync as it is being handled */
        bRatSyncWasRequested = false;

        /* Stop and synchronize the RAT if it is running */
        if(HWREG(RFC_PWR_BASE + RFC_PWR_O_PWMCLKEN) & RFC_PWR_PWMCLKEN_RAT_M)
        {
            /* Setup RAT_SYNC command to follow FsPowerdown command */
            ratCmd.stop.commandNo                 = CMD_SYNC_STOP_RAT;
            ratCmd.stop.condition.rule            = COND_NEVER;
            ratCmd.stop.startTrigger.triggerType  = TRIG_NOW;
            ratCmd.stop.pNextOp                   = NULL;

            /* Enter critical section */
            uint32_t key = HwiP_disable();

            /* Disable CPE last command done interrupt */
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFCPEIEN) &= ~RFC_DBELL_RFCPEIEN_LAST_COMMAND_DONE_M;

            /* Clear CPE last command done interrupt flag */
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFCPEIFG) = ~RFC_DBELL_RFCPEIFG_LAST_COMMAND_DONE_M;

            /* Send RAT Stop command */
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_CMDR) = (uint32_t)&ratCmd.stop;

            /* Wait till RAT Stop command to complete */
            while (!(HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFCPEIFG) & RFC_DBELL_RFCPEIFG_LAST_COMMAND_DONE_M));

            /* Clear CPE last command done interrupt flag and enable last command done interrupt */
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFCPEIFG) = ~RFC_DBELL_RFCPEIFG_LAST_COMMAND_DONE_M;
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFCPEIEN) |= RFC_DBELL_RFCPEIEN_LAST_COMMAND_DONE_M;

            /* Leave critical section */
            HwiP_restore(key);
        }
    }

    /* Reset nRtc1 */
    nRtc1 = 0;

    /* Turn off Synth */
    RFCSynthPowerDown();

    /* Turn off CPE */
    RFCClockDisable();
}

/*-------------- Power constraints internal functions ------------------------*/

/*
 * Set RF power constraints.
 *
 * Input:  src - RF_PowerConstraintSrc (Source: Queue or RAT)
 * Return: none
 */
void rfSetConstraint(RF_PowerConstraintSrc src)
{
    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Set constraint based on source */
    RF_powerConstraint |= src;

    /* Exit critical section */
    HwiP_restore(key);
}

/*
 * Release RF power constraints.
 *
 * Input:  src - RF_PowerConstraintSrc (Source: Queue or RAT)
 * Return: none
 */
void rfReleaseConstraint(RF_PowerConstraintSrc src)
{
    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* No need to do anything if all constraints are clear already */
    if (RF_powerConstraint)
    {
        /* Release this constraint */
        RF_powerConstraint &= ~src;

        /* Evaluate if the RF core can be forced to power off. */
        if(!(RF_powerConstraint & RF_PowerConstraintCmdQ) &&
           !(RF_powerConstraint & RF_PowerConstraintDisallow) &&
             RF_powerConstraint)
        {
            if(ratReleaseChannels())
            {
                RF_powerConstraint = 0;
            }
        }
    }

    /* Check if all constraints are clear */
    if (!RF_powerConstraint)
    {
        /* Initiate power down if all constraints are clear */
        SwiP_or(&swiFsm, RF_FsmEventPowerDown);
    }

    /* Exit critical section */
    HwiP_restore(key);
}

/*
 *  It calculates and returns the closest RF event in time if any.
 *
 *  Calling context: Hwi, Swi
 *
 *  Input:   dispatchTime - pointer to a container where the calculated time can be returned
 *  Return:  ticks - If command is far away in future.
 *           0     - If command is too close and should be scheduled now.
 */
static bool calculateDispatchTime(uint32_t* dispatchTimeClockTicks)
{
    /* Local variables. */
    uint32_t deltaTimeCmdClockTick;
    uint32_t deltaTimeRatClockTicks;

    /* Calculate the timestamp of the next command in the command queue. */
    bool validCmdTime = cmdDispatchTime(&deltaTimeCmdClockTick);

    /* If any of the RAT timers expire before the command should be dispatched,
       reprogram the power up clock to the RAT event instead. */
    bool validRatTime = ratDispatchTime(&deltaTimeRatClockTicks);

    if(validCmdTime && validRatTime)
    {
        /* Determine if command execution or RAT event comes first. */
        *dispatchTimeClockTicks = MIN(deltaTimeCmdClockTick, deltaTimeRatClockTicks);
    }
    else if (validCmdTime)
    {
        *dispatchTimeClockTicks = deltaTimeCmdClockTick;
    }
    else if (validRatTime)
    {
        *dispatchTimeClockTicks = deltaTimeRatClockTicks;
    }
    else
    {
        *dispatchTimeClockTicks = 0;
    }

    /* If any of them valid, return with true indicating a valid dispatch time. */
    return (validCmdTime || validRatTime);
}

/*
 *  Dispatch the closest event generated either by a command or the RAT timer.
 *  If the RF core is powered, it triggs the HWI to execute the dispatcher.
 *  If the RF core is not powered, it decides if it should be powered ON immediately, or
 *  the execution can be deferred to a later timestamp. In the latter case, the RTC is used to keep
 *  track of proper timing.
 *
 *  Input:  none
 *  Return: status - Status of the command execution.
 *
 */
static void dispatchNextEvent(void)
{
    if(bRadioIsActive)
    {
        /* Kick the HWI to dispatch the next pending event. */
        HwiP_post(INT_RFC_CPE_0);
    }
    else if (!bRadioIsBeingPoweredUp)
    {
        /* Enter critical section. */
        uint32_t key = HwiP_disable();

        /* Calculate dispatch time. */
        uint32_t dispatchTimeClockTicks;
        bool validTime = calculateDispatchTime(&dispatchTimeClockTicks);

        if(validTime)
        {
            /* Decide whether the command should be dispatched. */
            if (bRadioIsBeingPoweredDown)
            {
                /* In the middle of power down, indicate that the radio will
                   need to be powered up again immediately. */
                bRadioRestartIsRequested = true;
            }
            else if (dispatchTimeClockTicks)
            {
                /* Dispatch command in the future. */
                restartClockTimeout(&clkPowerUp, dispatchTimeClockTicks);
            }
            else
            {
                /* Initiate PHY change through the radio state machine. */
                SwiP_or(&swiFsm, RF_FsmEventWakeup);
            }
        }

        /* Exit critical section. */
        HwiP_restore(key);
    }
}

/*
 *  Update the cached FS command.
 *
 *  Calling context: Hwi, Swi
 *
 *  Input:   pCmd - Pointer to radio operation command
 *  Return:  none
 */
static void cacheFsCmd(RF_Cmd* pCmd)
{
    /* Upper limit of the number of operations in a chain */
    uint8_t nCmdChainMax = RF_MAX_CHAIN_CMD_LEN;

    /* Traverse the chain */
    RF_Op* pOp = pCmd->pOp;
    while (pOp && nCmdChainMax)
    {
        /* If the operation is a CMD_FS or CMD_FS_OFF */
        if ((pOp->commandNo == CMD_FS) || (pOp->commandNo == CMD_FS_OFF))
        {
            /* Create a copy of the first CMD_FS command (or CMD_FS_OFF) for later power up */
            memcpy(&pCmd->pClient->state.mode_state.cmdFs, pOp, sizeof(pCmd->pClient->state.mode_state.cmdFs));
            break;
        }

        /* Step the chain */
        pOp = pOp->pNextOp;

        /* Avoid infinit loop (in case of closed loops) */
        --nCmdChainMax;
    }
}


/*
 *  It decides whether the command should be dispatched now or not.
 *
 *  Input:  none
 *  Return: none
 */
static void triggDispatcher(void)
{
    /* If there is no running command */
    if(!cmdQ.pCurrCmd)
    {
        dispatchNextEvent();
    }
}


/*
 *  Submit the pending command to the RF Core.
 *
 *  Input:  none
 *  Return: none
 */
static void dispatchNextCmd(void)
{
    /* First element in the pend queue */
    RF_Cmd* pNextCmd = Q_peek(&cmdQ.pPend);

    /* If there is no running command, dispatch the next pending in the queue */
    if (!cmdQ.pCurrCmd)
    {
        if(pNextCmd)
        {
            /* Calculate the timestamp of the next command in the command queue. */
            uint32_t dispatchTimeClockTicks;
            bool validTime = cmdDispatchTime(&dispatchTimeClockTicks);

            /* Dispatch command in the future, if there is a command and the dispatch time is not 0 (immediate) */
            if (validTime && dispatchTimeClockTicks)
            {
                /* Command sufficiently far into future that it shouldn't be dispatched yet.
                   Release RF power constraint and potentially power down radio */
                rfReleaseConstraint(RF_PowerConstraintCmdQ);
            }
            else
            {
                /* Set power constraint on the command queue, since there is now a running command. */
                rfSetConstraint(RF_PowerConstraintCmdQ);

                /* Dispatch command immediately. Enable the requested interrupt sources of the command */
                HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFCPEIEN) |= (pNextCmd->bmEvent &  RF_INTERNAL_CPE_IFG_MASK_32_BIT);
                HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFHWIEN)  |= (pNextCmd->bmEvent >> RF_SHIFT_32_BITS);

                /* Dispatch immediately, set command to current and remove from pending queue */
                HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFACKIFG) = 0;
                HWREG(RFC_DBELL_BASE + RFC_DBELL_O_CMDR)     = (uint32_t)pNextCmd->pOp;
                while(!HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFACKIFG));

                /* Command now sent to the RF Core. Move it from pending queue to the current command */
                cmdQ.pCurrCmd = Q_pop(&cmdQ.pPend);
            }
        }
        else
        {
            /* No more pending command in the queue */
            SwiP_or(&swiFsm, RF_FsmEventLastCommandDone);
        }
    }
}

/*
 *  RF HW ISR when radio is active.
 *
 *  Input:  a - Not used.
 *  Return: none
 */
static void hwiFxnHw(uintptr_t a)
{
    /* Prepare a direct command. */
    RF_Cmd* pCmd = cmdQ.pCurrCmd;

    /* Read and clear the interrupt flags. */
    uint32_t rfchwifg = RFCHWIntGetAndClear(RF_HW_INT_CPE_MASK | RF_HW_INT_RAT_CH_MASK);
    uint32_t rfchwien = HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFHWIEN) & RF_HW_INT_CPE_MASK;
    uint32_t rathwien = HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFHWIEN) & RF_HW_INT_RAT_CH_MASK;

    /* Check for CPE interrupts. These belong to the FSM statem-achine. */
    if (rfchwifg & rfchwien)
    {
        if (pCmd)
        {
            /* Store the command which callback need to be served */
            cmdQ.pCurrCmdCb = pCmd;

            /* Accumulate the event within the command chain. This will be used if RF_pendCmd is called. */
            pCmd->pastifg |= ((RF_EventMask)(rfchwifg & rfchwien) << RF_SHIFT_32_BITS);

            /* Trig the state machine to handle this event */
            SwiP_or(&swiFsm, RF_FsmEventHwInt);
        }
    }

    /* Check for RAT channel events. These belong to the HW SWI. */
    if (rfchwifg & rathwien)
    {
        /* Store the channel which cause the interrupt */
        ratModule.pendingInt |= (rfchwifg & rathwien) >> RFC_DBELL_RFHWIFG_RATCH5_BITN;

        /* Post the swi to handle its callback */
        SwiP_or(&swiHw, 0);
    }
}


/*
 *  Software interrupt handler which servers Radio Timer (RAT) related events.
 *
 *  Input:  a    - Generic argument. Not used.
 *          b    - Generic argument. Not used.
 *  Return: none
 */
static void swiFxnHw(uintptr_t a, uintptr_t b)
{
    /* Local variable */
    bool error = false;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* If the interrupt was trigged due to one of the RAT channels*/
    if (ratModule.pendingInt)
    {
        /* Process lower channel first and allow multiple interrupt flags to be processed sequentially */
        uint32_t i;
        for(i = 0; i < RF_RAT_CH_CNT; i++)
        {
            if (ratModule.pendingInt & (RF_RAT_INTERRUPT_BASE_INDEX << i))
            {
                /* If there is also a bit indicating that the interrupt is due to an error. */
                if(ratModule.pendingInt & (RF_RAT_ERROR_BASE_INDEX << i)) error = true;

                /* Clear the interrupt flag and its shadow flag (which can indicate an error). */
                ratModule.pendingInt &= ~((RF_RAT_INTERRUPT_BASE_INDEX | RF_RAT_ERROR_BASE_INDEX) << i);

                /* Convert the channel index to a pointer of rat configuration. */
                RAT_Channel* ratCh = ratGetChannel(i);

                if(ratCh)
                {
                    /* Temporarily store the callback handler and the channel offset.
                       This is necessary in order to be able to free and reallocate the
                       same channel within the context of the callback itself. */
                    RF_Handle    ratClient        = (RF_Handle)ratCh->pClient;
                    RF_CmdHandle ratHandle        = (RF_CmdHandle)ratCh->handle;
                    RF_Callback  ratCallback      = (RF_Callback)ratCh->pCb;
                    if(error)
                    {
                        ratCallback = (RF_Callback)ratCh->pClient->clientConfig.pErrCb;
                    }

                    /* Only free the channel if it is not in repeated capture mode. */
                    if(error || !(ratCh->mode == RF_RatModeCapture) || !(ratCh->arg & RF_RAT_CPT_CONFIG_REP_MASK))
                    {
                        /* Free RAT channel. If this is the last channel, it will delay with 1 LF edge to
                           calculate the next wake up event. */
                        ratFreeChannel(ratCh);
                    }

                    /* Serve the user/error callback. */
                    if(error) ratCallback(ratClient, RF_ERROR_RAT_PROG, RF_EventError);
                    else      ratCallback(ratClient, ratHandle, RF_EventRatCh);
                }

                /* Only serve one channel at a time. */
                break;
            }
        }
    }

    /* Exit critical section. */
    HwiP_restore(key);

    /* Repost the SWI again if multiple interrupt flags are still set. */
    if (ratModule.pendingInt)
    {
        SwiP_or(&swiHw, 0);
    }
}

/*
 *  The CPE0 ISR when radio is active. Assume that all IRQs relevant to command
 *  dispatcher are mapped here. Furthermore, assume that there is no need for
 *  critical sections here (i.e. that this ISR has higher priority than
 *  any HWI calling a RF API function or that HWIs can't call the RF API).
 *
 *  Input:  a - Not used.
 *  Return: none
 */
static void hwiFxnCpe0Active(uintptr_t a)
{
    /* Assume that the interrupts belong to the currently active command. */
    RF_Cmd* pCmd = cmdQ.pCurrCmd;

    /* Get and clear doorbell IRQs */
    uint32_t rfcpeifg = RFCCpeIntGetAndClear();

    /* If there was a command running */
    if (pCmd)
    {
        /* The interrupt is either LAST_COMMAND_DONE or LAST_FG_COMMAND_DONE */
        if (rfcpeifg & RFC_DBELL_RFCPEIFG_LAST_COMMAND_DONE_M)
        {
            /* Retire the command by reseting the current command */
            cmdQ.pCurrCmd = NULL;

            /* Save RFCPEIFG for callback */
            pCmd->rfifg |= ((rfcpeifg & (RFC_DBELL_RFCPEIFG_LAST_COMMAND_DONE_M | pCmd->bmEvent)));

            /* Accumulate the event within the command chain. This will be used if RF_pendCmd is called. */
            pCmd->pastifg |= (RF_EventMask)pCmd->rfifg;

            /* Disable interrupt sources were subsribed by the command which is done now */
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFCPEIEN) &= ~(pCmd->bmEvent &  RF_INTERNAL_CPE_IFG_MASK_32_BIT);
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFHWIEN)  &= ~(pCmd->bmEvent >> RF_SHIFT_32_BITS);

            /* Move current command to done queue */
            Q_push(&cmdQ.pDone, pCmd, NULL);

            /* Post SWI to handle registered callbacks and potentially start inactivity timer */
            SwiP_or(&swiFsm, RF_FsmEventLastCommandDone);
        }
        else if (rfcpeifg & (pCmd->bmEvent))
        {
            /* The interrupt is for other reasons than LAST_COMMAND_DONE and the command is subscribed for this event */
            cmdQ.pCurrCmdCb = pCmd;

            /* Save CPEIFG for callback */
            pCmd->rfifg |= (rfcpeifg & pCmd->bmEvent);

            /* Accumulate the event within the command chain. This will be used if RF_pendCmd is called. */
            pCmd->pastifg |= (RF_EventMask)pCmd->rfifg;

            /* Post SWI to handle registered callbacks */
            SwiP_or(&swiFsm, RF_FsmEventCpeInt);
        }
    }

    /* Restart pending rat channels. */
    ratRestartChannels();

    /* Dispatch the next pending command if exists */
    dispatchNextCmd();
}

/*
 *  Clock callback due to inactivity timeout.
 *
 *  Input:  pObj - Not used.
 *  Return: none
 */
static void clkInactivityFxn(RF_Object* pObj)
{
    /* Decrement active client count and potentially signal to FSM that we can
       power down the RF core.  */
    rfReleaseConstraint(RF_PowerConstraintCmdQ);
}

/*
 *  Callback used to post semaphore for runCmd() and pendCmd().
 *
 *  Input:  h    - Handle to the client.
 *          ch   - Handle to the command which callback to be invoked.
 *          e    - Events causing the function call.
 *  Return: none
 */
static void syncCb(RF_Handle h, RF_CmdHandle ch, RF_EventMask e)
{
    /* Local variables */
    RF_Cmd* pCmd;

    /* If there is a user callback provided */
    if (h->state.pCbSync != NULL)
    {
        /* Invoke the user callback */
        ((RF_Callback)h->state.pCbSync)(h, ch, e);
    }

    /* Mask the possible causes of releasing the semaphore */
    RF_EventMask maskedEvents = (e & h->state.eventSync);

    /* Release the semaphore on any of the reasons: last command done,
       subscribed event happened, last FG command is done in IEEE mode */
    if (maskedEvents)
    {
        /* Find the command. We do it here within the SWI context. */
        pCmd = getCmd(ch, RF_CMD_ALLOC_FLAG);

        /* Store the events in the context of the client */
        h->state.unpendCause = maskedEvents;

        /* Find the command. We do it here within the SWI context. */
        if(pCmd)
        {
          /* Clear the handled past events so it is possible to pend again */
          pCmd->pastifg &= ~h->state.unpendCause;

          /* Exhange the callback function: use the user callback from this point */
          pCmd->pCb = (RF_Callback)h->state.pCbSync;
        }

        /* Clear temporary storage of user callback (it was restored and served at this point) */
        h->state.pCbSync = NULL;

        /* Post the semaphore to release the RF_pendCmd() */
        SemaphoreP_post(&h->state.semSync);
    }
}


/*
 *  Default callback function.
 *
 *  Input:  h    - Handle to the client.
 *          ch   - Handle to the command which callback to be invoked.
 *          e    - Events causing the function call.
 *  Return: none
 */
static void defaultCallback(RF_Handle h, RF_CmdHandle ch, RF_EventMask e)
{
  /* Do nothing */;
}

/*-------------- RF powerup/powerdown FSM functions ---------------*/

/*
 *  Set target state transition.
 *
 *  Input:  pTarget - Pointer to the next state.
 *  Return: none
 */
static void FsmNextState(Fsm_StateFxn pTarget)
{
    pFsmState = pTarget;
}


/*
 *  The SWI handler for FSM events.
 *
 *  Input:  a0 - Not used.
 *          a1 - Not used.
 *  Return: none
 */
static void swiFxnFsm(uintptr_t a0, uintptr_t a1)
{
    pFsmState(pCurrClient, (RF_FsmEvent)SwiP_getTrigger());
}


/*
 *  Clock callback called upon powerup.
 *
 *  Input:  a - Not used.
 *  Return: none
 */
static void clkPowerUpFxn(uintptr_t a)
{
    /* Trigger FSM SWI to get radio wakeup going */
    SwiP_or(&swiFsm, RF_FsmEventWakeup);
}


/*
 *  RF CPE0 ISR during FSM powerup/powerdown.
 *
 *  Input:  a0 - Not used.
 *  Return: none
 */
static void hwiFxnCpe0PowerFsm(uintptr_t a0)
{
    /* Read all IRQ flags in doorbell and then clear them */
    uint32_t rfcpeifg = RFCCpeIntGetAndClear();

    /* Handle special events as boot, etc */
    if (rfcpeifg & (IRQ_BOOT_DONE | IRQ_LAST_COMMAND_DONE))
    {
        SwiP_or(&swiFsm, RF_FsmEventPowerStep);
    }
}

/*-------------- Power management state functions ---------------*/
/*
 *  Handles RF Core patching for CPE, MCE, RFE (if required) in setup state during power-up.
 *
 *  Input:  mode - Not used.
 *  Return: none
 */
static void applyRfCorePatch(bool mode)
{
    /* Patch CPE if relevant */
    if (pCurrClient->clientConfig.pRfMode->cpePatchFxn)
    {
        pCurrClient->clientConfig.pRfMode->cpePatchFxn();
    }

    if ((pCurrClient->clientConfig.pRfMode->mcePatchFxn != 0) || (pCurrClient->clientConfig.pRfMode->rfePatchFxn != 0))
    {
        /* Wait for clocks to turn on */
        while(!HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFACKIFG));
        HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFACKIFG) = 0;

        /* Patch if relevant */
        if (pCurrClient->clientConfig.pRfMode->mcePatchFxn)
        {
            pCurrClient->clientConfig.pRfMode->mcePatchFxn();
        }

        /* Patch if relevant */
        if (pCurrClient->clientConfig.pRfMode->rfePatchFxn)
        {
            pCurrClient->clientConfig.pRfMode->rfePatchFxn();
        }

        /* Turn off additional clocks */
        RFCDoorbellSendTo(CMDR_DIR_CMD_2BYTE(RF_CMD0, 0));
    }
}

/*
 *  Handle callback to client for RF_EventLastCmdDone and issue radio free callback if required.
 *
 *  Input:  none
 *  Return: none
 */
static void radioOpDoneCb(void)
{
    /* Serve the first entry in the done queue */
    RF_Cmd* pCmd = Q_peek(&cmdQ.pDone);

    /* Radio command done */
    if (pCmd)
    {
        /* Update implicit radio state */
        cacheFsCmd(pCmd);

        /* Read and clear the events */
        uint32_t tmp = pCmd->rfifg;
        pCmd->rfifg = 0;

        /* Issue callback, free container and dequeue */
        if (pCmd->pCb)
        {
            /* Add the last command done */
            RF_EventMask cb_e = (RF_EventMask)(tmp | RF_EventLastCmdDone);

            /* If the command was cancelled, stopped or aborted, overwrite the events */
            switch (pCmd->flags & RF_CMD_CANCEL_MASK)
            {
                case RF_CMD_ABORTED_FLAG:
                    cb_e = RF_EventCmdAborted;
                    break;
                case RF_CMD_STOPPED_FLAG:
                    cb_e = RF_EventCmdStopped;
                    break;
                case RF_CMD_CANCELLED_FLAG:
                    cb_e = RF_EventCmdCancelled;
                    break;
                default:
                    break;
            }

            /* Invoke the use callback */
            pCmd->pCb(pCmd->pClient, pCmd->ch, cb_e);
        }

        /* Enter critical section */
        uint32_t key = HwiP_disable();

        /* Update num of radio command done */
        cmdQ.nSeqDone = (cmdQ.nSeqDone+1)&N_CMD_MODMASK;

        /* Commmand completed reset command flags  */
        cmdQ.pDone->flags = 0;

        /* Command completed, free command queue container */
        Q_pop(&cmdQ.pDone);

        /* Exit critical section */
        HwiP_restore(key);

        /* Check if there are any more pending commands for this client */
        if (cmdQ.nSeqDone == pCmd->pClient->state.chLastPosted)
        {
            /* This was last posted command for client */
            if (pCmd->pClient->state.bYielded || (pCmd->pClient->clientConfig.nInactivityTimeout == 0))
            {
                /* Clear the indication of yielding the client. */
                pCmd->pClient->state.bYielded = false;

                /* Initiate power down immediately. */
                rfReleaseConstraint(RF_PowerConstraintCmdQ);
            }
            else
            {
                /* If there is a valid inactivity time set */
                if (pCurrClient->clientConfig.nInactivityTimeout != SemaphoreP_WAIT_FOREVER)
                {
                    /* Start inactivity timer */
                    uint32_t timeoutClockTicks = MAX(pCmd->pClient->clientConfig.nInactivityTimeout/ClockP_tickPeriod, 1);
                    restartClockTimeout(&pCmd->pClient->state.clkInactivity, timeoutClockTicks);
                }
            }
        }
    }
}

/*
 *  RF state machine function during power up state.
 *
 *  Input:  pObj - Pointer to RF object.
 *          e    - State machine event.
 *  Return: none
 */
static void fsmPowerUpState(RF_Object *pObj, RF_FsmEvent e)
{
    /* Note: pObj is NULL in this state */
    if (e & RF_FsmEventLastCommandDone)
    {
        /* Serve the registered callback function */
        radioOpDoneCb();

        /* We've handled this event now */
        e &= ~RF_FsmEventLastCommandDone;

        /* Retrig the SWI if there are more commands in the done queue */
        if (Q_peek(&cmdQ.pDone))
        {
            /* Trigger self if there are more commands in callback queue */
            SwiP_or(&swiFsm, (e | RF_FsmEventLastCommandDone));
        }
        else if ((e & RF_FsmEventWakeup) || (Q_peek(&cmdQ.pPend)))
        {
            /* If there is pending cmd, just wake up */
            /* Device will put to sleep if the pending cmd is future cmd */
            ClockP_stop(&clkPowerUp);

            /* trigger power up */
            SwiP_or(&swiFsm, RF_FsmEventWakeup);
        }
    }
    else if(e & RF_FsmEventWakeup)
    {
        /* Disable system going to IDLE mode */
        bDisableFlashInIdleConstraint = true;
        Power_setConstraint(PowerCC26XX_NEED_FLASH_IN_IDLE);

        nRtc1  = AONRTCCurrent64BitValueGet();

        /* Set current client from first command in command queue */
        RF_Cmd* pNextCmd = Q_peek(&cmdQ.pPend);
        if (pNextCmd)
        {
            pCurrClient = pNextCmd->pClient;
        }

        /* Set the RF mode in the PRCM register */
        HWREG(PRCM_BASE + PRCM_O_RFCMODESEL) = pCurrClient->clientConfig.pRfMode->rfMode;

        /* Register power dependency and constraints - i.e. power up RF. */
        Power_setConstraint(PowerCC26XX_SB_DISALLOW);
        Power_setDependency(PowerCC26XX_DOMAIN_RFCORE);

        /* Start power-up sequence */
        bRadioIsBeingPoweredUp = true;

        if((pCurrClient->clientConfig.bPowerUpXOSC == false) || bRadioHasBeenBootedBefore == false)
        {
            Power_setDependency(PowerCC26XX_XOSC_HF);
        }

        /* Turn on additional clocks on boot */
        if ((pCurrClient->clientConfig.pRfMode->mcePatchFxn != 0) || (pCurrClient->clientConfig.pRfMode->rfePatchFxn != 0))
        {
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFACKIFG) = 0;
            HWREG(RFC_DBELL_BASE+RFC_DBELL_O_CMDR)       = CMDR_DIR_CMD_2BYTE(RF_CMD0, RFC_PWR_PWMCLKEN_MDMRAM | RFC_PWR_PWMCLKEN_RFERAM);
        }

        /* Turn on clock to RF core */
        RFCClockEnable();

        /* Map all radio interrupts to CPE0 and enable some sources */
        HWREG(RFC_DBELL_BASE+RFC_DBELL_O_RFCPEISL) = 0;

        HWREG(RFC_DBELL_BASE+RFC_DBELL_O_RFCPEIEN) = RFC_DBELL_RFCPEIEN_LAST_COMMAND_DONE_M |
                                                     RFC_DBELL_RFCPEIEN_BOOT_DONE_M;

        /* Next FSM state */
        FsmNextState(&fsmSetupState);

        /* Enable interrupts and let BOOT_DONE interrupt kick things off */
        HwiP_enableInterrupt(INT_RFC_CPE_0);
    }
}

/*
 *  RF state machine function during setup state.
 *
 *  Input:  pObj - Pointer to RF object.
 *          e    - State machine event.
 *  Return: none
 */
static void fsmSetupState(RF_Object *pObj, RF_FsmEvent e)
{
    if (e & RF_FsmEventPowerStep)
    {
        /* Apply RF Core patch (if required) */
        applyRfCorePatch(RF_PHY_BOOTUP_MODE);

        /* Initialize bus request */
        HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFACKIFG) = 0;
        HWREG(RFC_DBELL_BASE+RFC_DBELL_O_CMDR) = CMDR_DIR_CMD_1BYTE(CMD_BUS_REQUEST, 1);

        /* Set VCOLDO reference */
        RFCAdi3VcoLdoVoltageMode(true);

        /* Next state: fsmActiveState */
        FsmNextState(&fsmActiveState);

        /* Setup RAT_SYNC command to follow SETUP command */
        ratCmd.start.commandNo                = CMD_SYNC_START_RAT;
        ratCmd.start.status                   = IDLE;
        ratCmd.start.startTrigger.triggerType = TRIG_NOW;
        ratCmd.start.pNextOp                  = NULL;
        ratCmd.start.condition.rule           = COND_NEVER;    /* Default: don't chain */

        /* Setup SETUP command */
        RF_RadioSetup* pOpSetup = pObj->clientConfig.pOpSetup;
        pOpSetup->prop.status   = IDLE;

        /* For power saving - analogCfgMode is set to 0 only for the first power up */
        if ((bRadioHasBeenBootedBefore == false) || (pObj->clientConfig.bUpdateSetup))
        {
            if ((pObj->clientConfig.pOpSetup->commandId.commandNo == CMD_RADIO_SETUP) ||
                (pObj->clientConfig.pOpSetup->commandId.commandNo == CMD_BLE5_RADIO_SETUP))
            {
                /* BLE or IEEE mode. BLE 5.0 shares same offset for config.analogCfgMode with BLE radio setup */
                pOpSetup->common.config.analogCfgMode = RF_SETUP_ANALOGCFG_UPDATE;
            }
            else
            {
                /* Proprietary mode */
                pOpSetup->prop.config.analogCfgMode = RF_SETUP_ANALOGCFG_UPDATE;
            }

            pObj->clientConfig.bUpdateSetup = false;
        }

        /* Trim directly the radio register values based on the ID of setup command */
        rfTrim_t rfTrim;
        RFCRfTrimRead((rfc_radioOp_t*)pObj->clientConfig.pOpSetup, (rfTrim_t*)&rfTrim);
        RFCRfTrimSet((rfTrim_t*)&rfTrim);

        RF_Op* tmp = (RF_Op*)&pOpSetup->prop;
        while ((tmp->pNextOp) && (tmp->pNextOp->commandNo != CMD_SYNC_START_RAT))
        {
            tmp = tmp->pNextOp;
        }
        tmp->pNextOp        = (RF_Op*)&ratCmd.start;
        tmp->condition.rule = COND_ALWAYS;

        /* Setup FS command to follow SETUP command */
        rfc_CMD_FS_t* pOpFs;
        RF_Op* pOpFirstPend = Q_peek(&cmdQ.pPend)->pOp;
        if ((pOpFirstPend->commandNo == CMD_FS) || (pOpFirstPend->commandNo == CMD_FS_OFF))
        {
            /* First command is FS command so no need to chain an implicit FS command
               Reset nRtc1 */
            nRtc1 = 0;
        }
        else
        {
            if (pObj->state.mode_state.cmdFs.commandNo)
            {
                /* Chain in the implicit FS command */
                pOpFs                           = &pObj->state.mode_state.cmdFs;
                pOpFs->status                   = IDLE;
                pOpFs->pNextOp                  = NULL;
                pOpFs->startTrigger.triggerType = TRIG_NOW;
                pOpFs->condition.rule           = COND_NEVER;
                ratCmd.start.pNextOp            = (RF_Op*)pOpFs;
                ratCmd.start.condition.rule     = COND_ALWAYS;
            }
        }

        /* Make sure BUS_REQUEST is done */
        while(!HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFACKIFG));
        HWREG(RFC_DBELL_BASE + RFC_DBELL_O_RFACKIFG) = 0;

        /* power up the frequency synthesizer */
        pObj->clientConfig.pOpSetup->common.config.bNoFsPowerUp = 0;

        /* Run the XOSC_HF switching if the pre-notify function setup the power
           constraint PowerCC26XX_SWITCH_XOSC_HF_MANUALLY */
        if (bRadioDelegateXOSCHFSwitching)
        {
            /* Wait until the XOSC_HF is stable */
            while(!PowerCC26XX_isStableXOSC_HF());

            /* Run the XOSC_HF switch */
            PowerCC26XX_switchXOSC_HF();
        }
        else if (OSCClockSourceGet(OSC_SRC_CLK_HF) != OSC_XOSC_HF)
        {
            tmp->condition.rule = COND_NEVER;
            FsmNextState(&fsmXOSCState);
        }

        /* Send chain */
        HWREG(RFC_DBELL_BASE+RFC_DBELL_O_CMDR) = (uint32_t)&pObj->clientConfig.pOpSetup->commandId;
    }
}

/*
 *  RF state machine function during XOSC state.
 *
 *  Input:  pObj - Pointer to RF object.
 *          e    - State machine event.
 *  Return: none
 */
static void fsmXOSCState(RF_Object *pObj, RF_FsmEvent e)
{
    if ((e & RF_FsmEventPowerStep) || (e & RF_FsmEventWakeup))
    {
        /* If XOSC_HF is now ready */
        if(OSCClockSourceGet(OSC_SRC_CLK_HF) == OSC_XOSC_HF)
        {
            /* Next state: fsmActiveState */
            FsmNextState(&fsmActiveState);

            /* Continue with the CMD_RAT_SYNC */
            HWREG(RFC_DBELL_BASE + RFC_DBELL_O_CMDR) = (uint32_t)&ratCmd.start;
        }
        else
        {
            /* Clock source not yet switched to XOSC_HF: schedule new polling */
            uint32_t timeoutClockTicks = MAX(RF_XOSC_HF_SWITCH_CHECK_PERIOD/ClockP_tickPeriod, 1);
            restartClockTimeout(&clkPowerUp, timeoutClockTicks);
        }
    }
}

/*
 *  RF state machine function during active state.
 *
 *  Input:  pObj - Pointer to RF object.
 *          e    - State machine event.
 *  Return: none
 */
static void fsmActiveState(RF_Object *pObj, RF_FsmEvent e)
{
    RF_Cmd* pCmd;
    uint32_t rtcValTmp1;
    uint32_t rtcValTmp2;
    uint32_t rfifgTmp;

    if (e & RF_FsmEventCpeInt)
    {
        /* Enter critical section */
        uint32_t key = HwiP_disable();

        /* Dereference the command which requested the callback*/
        pCmd = Q_peek(&cmdQ.pCurrCmdCb);

        /* If this is due to other event than LastCmdDone */
        if (pCmd && !(pCmd->rfifg & RF_EventLastCmdDone))
        {
            /* Temporarily store the reason of callback */
            rfifgTmp = pCmd->rfifg;

            /* Clear the events which are handled here */
            pCmd->rfifg &= (~rfifgTmp);

            /* Exit critical section */
            HwiP_restore(key);

            /* Invoke the user callback if it is provided */
            if (pCmd->pCb)
            {
                pCmd->pCb(pCmd->pClient, pCmd->ch, (RF_EventMask)rfifgTmp);
            }
        }
        else
        {
            /* Exit critical section */
            HwiP_restore(key);
        }

        /* We've handled this event now */
        e &= ~RF_FsmEventCpeInt;
    }
    else if (e & RF_FsmEventLastCommandDone)
    {
        /* Issue radio operation done callback */
        radioOpDoneCb();

        /* We've handled this event now */
        e &= ~RF_FsmEventLastCommandDone;

        /* If there is more entries left in the done queue */
        if (Q_peek(&cmdQ.pDone))
        {
            /* Trigger self if there are more commands in done queue */
            e |= RF_FsmEventLastCommandDone;
        }
    }
    else if (e & RF_FsmEventPowerStep)
    {
        /* Release disable IDLE since power up is now complete */
        if (bDisableFlashInIdleConstraint)
        {
            Power_releaseConstraint(PowerCC26XX_NEED_FLASH_IN_IDLE);
            bDisableFlashInIdleConstraint = false;
        }

        /* For power saving, set analogCfgMode to 0x2D */
        if ((pObj->clientConfig.pOpSetup->commandId.commandNo == CMD_RADIO_SETUP) ||
            (pObj->clientConfig.pOpSetup->commandId.commandNo == CMD_BLE5_RADIO_SETUP))
        {
            pObj->clientConfig.pOpSetup->common.config.analogCfgMode = RF_SETUP_ANALOGCFG_NOUPDATE;
        }
        else
        {
            pObj->clientConfig.pOpSetup->prop.config.analogCfgMode = RF_SETUP_ANALOGCFG_NOUPDATE;
        }

        /* Update power up duration if coming from the clkPowerUpFxn (nRtc not zero) */
        if (nRtc1 && (OSCClockSourceGet(OSC_SRC_CLK_LF) != OSC_RCOSC_HF))
        {
            /* Take wake up timestamp and the current timestamp */
            rtcValTmp1  = (uint32_t)nRtc1;
            rtcValTmp2  = (uint32_t)AONRTCCurrent64BitValueGet();

            /* Temporary storage to be able to compare the new value to the old measurement */
            uint32_t prevPowerUpDuration = pObj->clientConfig.nPowerUpDuration;

            /* Calculate the difference of the timestamps and convert it to us units */
            pObj->clientConfig.nPowerUpDuration   = UDIFF(rtcValTmp1, rtcValTmp2);
            pObj->clientConfig.nPowerUpDuration >>= RF_RTC_CONV_TO_US_SHIFT;

            /* Add margin to the power up duration to account for the TIRTOS/Drivers overhead */
            pObj->clientConfig.nPowerUpDuration += pObj->clientConfig.nPowerUpDurationMargin;

            /* Low pass filter on power up durations less than in the previous cycle */
            if(prevPowerUpDuration > pObj->clientConfig.nPowerUpDuration)
            {
                /* Expect that the values are small and the calculation can be done in 32 bits */
                pObj->clientConfig.nPowerUpDuration = (prevPowerUpDuration + pObj->clientConfig.nPowerUpDuration)/2;
            }

            /* Power up duration should be within certain upper and lower bounds */
            if ((pObj->clientConfig.nPowerUpDuration > RF_DEFAULT_POWER_UP_TIME) ||
                (pObj->clientConfig.nPowerUpDuration < RF_DEFAULT_MIN_POWER_UP_TIME))
            {
                pObj->clientConfig.nPowerUpDuration = RF_DEFAULT_POWER_UP_TIME;
            }
        }

        /* Check the status of the CMD_FS, if it was sent (chained) to the setup command sent
           during RF_FsmEventChangePhy1 and return error callback to the client.
           The client can either resend the CMD_FS or ignore the error as per Errata on PG2.1 */
        if ((ratCmd.start.condition.rule == COND_ALWAYS) &&
            (pObj->state.mode_state.cmdFs.status == ERROR_SYNTH_PROG))
        {
            RF_Callback pErrCb = (RF_Callback)pObj->clientConfig.pErrCb;
            pErrCb(pObj, RF_ERROR_CMDFS_SYNTH_PROG, RF_EventError);
        }

        /* Change HWI handler */
        HwiP_setFunc(&hwiCpe0, hwiFxnCpe0Active, (uintptr_t)NULL);

        /* Get the available RAT channel map */
        if (bRatSyncWasRequested)
        {
            /* Prepare the radio command */
            rfc_CMD_GET_FW_INFO_t getFwInfoCmd;
            getFwInfoCmd.commandNo = CMD_GET_FW_INFO;

            /* Sent the command to the RF core */
            RFCDoorbellSendTo((uint32_t)&getFwInfoCmd);

            /* Read the updated data and store it in a global variable */
            ratModule.availRatCh = (getFwInfoCmd.availRatCh >> RF_RAT_CH_LOWEST);

            /* It is served now. */
            bRatSyncWasRequested = false;
        }

        /* Mark radio and client as being active */
        bRadioIsActive         = true;
        bRadioIsBeingPoweredUp = false;

        /* Make sure pending command gets issued by issuing CPE0 IRQ */
        dispatchNextEvent();

        /* Power up callback */
        RF_Callback pPowerCb = (RF_Callback)pObj->clientConfig.pPowerCb;
        pPowerCb(pObj, 0, RF_EventPowerUp);

        /* We've handled this event now */
        e &= ~RF_FsmEventPowerStep;
    }
    else if (e & RF_FsmEventPowerDown)
    {
        if (bRadioYieldWasCancelled)
        {
            bRadioYieldWasCancelled = false;
        }
        else
        {
            /* Stop inactivity timer. */
            ClockP_stop(&pCurrClient->state.clkInactivity);

            /* Recalculate the next wakeup event. */
            uint32_t dispatchTimeClockTicks;
            bool validTime = calculateDispatchTime(&dispatchTimeClockTicks);

            /* If there is any future event, reschedule the next wake up. */
            if(validTime)
            {
                restartClockTimeout(&clkPowerUp, dispatchTimeClockTicks);
            }

            /* Radio not active */
            bRadioIsActive           = false;
            bRadioIsBeingPoweredDown = true;

            /* Next state: fsmPowerUpState */
            FsmNextState(&fsmPowerUpState);

            /* Execute the power down sequence of the RF core. */
            powerDownRfCore();

            /* Closing all handles */
            if (!nClients)
            {
                SemaphoreP_post(&pCurrClient->state.semSync);
            }

            /* Release constraints and dependencies, turning off RF core */
            Power_releaseConstraint(PowerCC26XX_SB_DISALLOW);
            Power_releaseDependency(PowerCC26XX_DOMAIN_RFCORE);

            /* If there is no specific client request or the XOSC, release the dependency */
            if(pObj->clientConfig.bPowerUpXOSC == false)
            {
                Power_releaseDependency(PowerCC26XX_XOSC_HF);
            }

            /* Release constraint of switching XOSC_HF from the RF driver itself */
            if (bRadioDelegateXOSCHFSwitching == true)
            {
                bRadioDelegateXOSCHFSwitching = false;
                Power_releaseConstraint(PowerCC26XX_SWITCH_XOSC_HF_MANUALLY);
            }

            /* Radio powered down */
            bRadioIsBeingPoweredDown   = false;
            bRadioYieldingWasRequested = false;

            /* Start radio if required */
            if (bRadioRestartIsRequested)
            {
                bRadioRestartIsRequested = false;
                SwiP_or(&swiFsm, RF_FsmEventWakeup);
            }
        }

        /* We've handled this event now */
        e &= ~RF_FsmEventPowerDown;
    }
    else if (e & RF_FsmEventHwInt)
    {
        /* Serve the callback of the running command*/
        pCmd = Q_peek(&cmdQ.pCurrCmd);

        /* If there is any callback registered, invoke it */
        if (pCmd && pCmd->pCb)
        {
            pCmd->pCb(pCmd->pClient, pCmd->ch, RF_EventMdmSoft);
        }
        /* We've handled this event now */
        e &= ~RF_FsmEventHwInt;
    }
    else
    {
        /* No other FSM event has any effect */
    }

    /* Call self again if there are outstanding events to be processed */
    if (e)
    {
        SwiP_or(&swiFsm, e);
    }
}

/*-------------- Initialization & helper functions ---------------*/

/*
 *  Initialize RF driver.
 *
 *  Input:  none
 *  Return: none
 */
static void rf_init(void)
{
    union {
        HwiP_Params hp;
        SwiP_Params sp;
    } params;

    /* Power init */
    Power_init();

    /* Enable output RTC clock for Radio Timer Synchronization */
    HWREG(AON_RTC_BASE + AON_RTC_O_CTL) |= AON_RTC_CTL_RTC_UPD_EN_M;

    /* Initialize SWI used for the CPE interrupts */
    SwiP_Params_init(&params.sp);
    params.sp.priority = RFCC26XX_hwAttrs.swiCpe0Priority;
    SwiP_construct(&swiFsm, swiFxnFsm, &params.sp);

    /* Initialize HWI used for the CPE interrupts */
    HwiP_Params_init(&params.hp);
    params.hp.enableInt = false;
    params.hp.priority  = RFCC26XX_hwAttrs.hwiCpe0Priority;
    HwiP_construct(&hwiCpe0, INT_RFC_CPE_0, hwiFxnCpe0PowerFsm, &params.hp);

    /* Initialize SWI used for the HW interrupts */
    SwiP_Params_init(&params.sp);
    params.sp.priority = RFCC26XX_hwAttrs.swiHwPriority;
    SwiP_construct(&swiHw, swiFxnHw, &params.sp);

    /* Initialize HWI used for the HW interrupts */
    HwiP_Params_init(&params.hp);
    params.hp.enableInt = true;
    params.hp.priority  = RFCC26XX_hwAttrs.hwiHwPriority;
    HwiP_construct(&hwiHw, INT_RFC_HW_COMB, hwiFxnHw, &params.hp);

    /* Initialize clock object used as power-up trigger */
    ClockP_construct(&clkPowerUp, &clkPowerUpFxn, 0, NULL);

    /* Set FSM state to power up */
    FsmNextState(fsmPowerUpState);

    /* Subscribe to wakeup notification from the Power driver */
    Power_registerNotify(&RF_wakeupNotifyObj,                   /* Object to register */
                         PowerCC26XX_AWAKE_STANDBY,             /* Event the notification to be invoked upon */
                         (Power_NotifyFxn) RF_wakeupNotifyFxn,  /* Function to be invoked */
                         (uintptr_t) NULL);                     /* Parameters */

    /* Initialize global variables */
    ratModule.availRatCh          = RF_DEFAULT_AVAILRATCH_VAL;
    bRatSyncWasRequested          = true;
    bRadioHasBeenBootedBefore     = false;
    bRadioIsBeingPoweredUp        = false;
    bRadioIsBeingPoweredDown      = false;
    bRadioYieldingWasRequested    = false;
    bRadioYieldWasCancelled       = false;
    bRadioDelegateXOSCHFSwitching = false;
    bDisableFlashInIdleConstraint = false;
    nRtc1                         = 0;
    errTolValInUs                 = RF_DEFAULT_RAT_RTC_ERR_TOL_IN_US;
}

/*
 *  Trace through the pending queue and flush the command(s).
 *
 *  Input:  h         - Handle to the client calling this function.
 *          pCmd      - Pointer to the command where the cancelling should start with.
 *          bFlushAll - Decides weather one or more commands should be aborted.
 *  Return: Number of commands was terminated.
 */
static uint32_t discardPendCmd(RF_Handle h, RF_Cmd *pCmd, bool bFlushAll)
{
    /* Local variable counts the number of command cancelled. */
    uint32_t nDiscarded = 0;

    /* If it is possible, start to flush from the beginning of pend queue. */
    if(pCmd == cmdQ.pPend)
    {
        /* If the head of the queue belongs to the client, remove the command. */
        while (pCmd)
        {
            /* Mark the command as being cancelled. */
            pCmd->flags |= RF_CMD_CANCELLED_FLAG;

            /* Step the head of the queue. */
            Q_pop(&cmdQ.pPend);

            /* Push the command to the done queue. */
            Q_push(&cmdQ.pDone, pCmd, NULL);

            /* Take the next command as the head of the queue. */
            pCmd = cmdQ.pPend;

            /* Increment the counter. */
            nDiscarded += 1;

            /* Break the loop if only single cancel was requested. */
            if(!bFlushAll)
            {
                return nDiscarded;
            }
        }
    }
    else
    {
        /* Start the search from the beginning of the queue. */
        RF_Cmd* pTmp = cmdQ.pPend;

        /* Stop the search before we reach the command. */
        while(pTmp && pTmp->pNext && (pTmp->pNext != pCmd))
        {
            pTmp = pTmp->pNext;
        }

        /* We will flush from pCmd->Next. */
        pCmd = pTmp;
    }

    /* Cancel the commands from pCmd->pNext if it belongs to the client. */
    while(pCmd)
    {
        if (pCmd->pNext)
        {
            /* Remove command from the pending queue. */
            RF_Cmd* pCmdCancel = (RF_Cmd*)pCmd->pNext;

            /* Mark the command as being cancelled. */
            pCmdCancel->flags |= RF_CMD_CANCELLED_FLAG;

            /* Delete reference to the cancelled command. */
            pCmd->pNext = pCmdCancel->pNext;

            /* Push the command to the done queue. */
            Q_push(&cmdQ.pDone, pCmdCancel, NULL);

            /* Increment the counter. */
            nDiscarded += 1;

            /* Break the loop if only single cancel was requested. */
            if(!bFlushAll)
            {
                return nDiscarded;
            }
        }
        else
        {
            /* Step the queue if it belong to the other client. */
            pCmd = pCmd->pNext;
        }
    }

    /* Return with the number of cancelled commands. */
    return nDiscarded;
}

/*
 *  Process cancel commands. It is used by RF_cancelCmd, RF_flushCmd API.
 *
 *  Input:  h    - Handle to the client calling this function.
 *          ch   - Handle to the command where the cancelling should start with.
 *          type - Flags decide how should we terminate the command.
 *  Retrun: status
 */
static RF_Stat abortCmd(RF_Handle h, RF_CmdHandle ch, uint8_t type)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Initialize local variables */
    RF_Cmd* pCmd                = NULL;
    bool bGraceful              = type & RF_ABORT_CANCEL_SINGLE_CMD;
    bool bFlush                 = type & RF_ABORT_CANCEL_MULTIPLE_CMD;
    RF_Stat status              = RF_StatInvalidParamsError;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Handle FLUSH_ALL request */
    if (ch == RF_CMDHANDLE_FLUSH_ALL)
    {
        /* If the current command belongs to this client, cancel it first.
         Otherwise, walk the pend queue and cancel commands belong to this client. */
        pCmd = (cmdQ.pCurrCmd ? cmdQ.pCurrCmd : cmdQ.pPend);
    }
    else
    {
        /* Search for the command in the command pool based on its handle. The command can
          locate on any of the queues at this point. */
        pCmd = getCmd(ch, 0x00);
    }

    /* If command handle is valid, proceed to cancel. */
    if (pCmd)
    {
        /* If command is still in the pool but it is not allocated anymore, i.e. it was already served. */
        if(!(pCmd->flags & RF_CMD_ALLOC_FLAG))
        {
          /* Return with a special status byte to the user. */
          status = RF_StatCmdEnded;
        }
        else
        {
            /* If the command we want to cancel is actively running. */
            if (pCmd == cmdQ.pCurrCmd)
            {
                /* Flag that the command has been aborted. */
                pCmd->flags |= (1 << bGraceful);

                /* Send the abort/stop command through the doorbell to the RF core. */
                RFCDoorbellSendTo((bGraceful) ? CMDR_DIR_CMD(CMD_STOP) : CMDR_DIR_CMD(CMD_ABORT));

                /* Remove all commands from the pend queue belong to this client. Only do it
                   if it was explicitely requested through the RF_ABORT_CANCEL_MULTIPLE_CMD flag. */
                if (bFlush)
                {
                    discardPendCmd(h, cmdQ.pPend, bFlush);
                }

                /* Return with success as we cancelled at least the currently running command. */
                status = RF_StatSuccess;
            }
            else
            {
                /* Remove one/all commands from the pend queue based on the RF_ABORT_CANCEL_MULTIPLE_CMD
                   argument. If at least one command is cancelled the operation was succesful. Otherwise,
                   either the pend queue is empty or pCmd have terminated earlier */
                if(discardPendCmd(h, pCmd, bFlush))
                {
                    /* Stop the scheduling clock. We will restart the clock according to the first
                       entry in the new queue. */
                    ClockP_stop(&clkPowerUp);

                    /* Kick the state machine to handle the done queue. This is not necessary
                       when the RF is currently performing a power-up. */
                    if(bRadioIsBeingPoweredUp == false)
                    {
                        SwiP_or(&swiFsm, RF_FsmEventLastCommandDone);
                    }

                    /* At least one command was cancelled. */
                    status = RF_StatSuccess;
                }
                else
                {
                    /* The command is not running and is not in the pend queue. It is located on the
                       done queue, hence return RF_StatCmdEnded. */
                    status = RF_StatCmdEnded;
                }
            }
        }
    }

    /* Exit critical section */
    HwiP_restore(key);

    /* Return with the result:
     - RF_StatSuccess if at least one command was cancelled.
     - RF_StatCmdEnded, when the command already finished.
     - RF_StatInvalidParamsError otherwise.  */
    return status;
}

/*
 *  Execute a direct or immediate command in the RF Core if possible.
 *
 *  Input:  pCmd                       - Pointer to the command which shall be sent to the RF core.
 *          rawStatus                  - Return address of the raw status byte read from the CMDSTA register.
 *  Return: The return value interprets and converts the result of command execution to and RF_Stat value.
 *          RF_StatCmdDoneSuccess       - If the command was sent and accepted by the RF core.
 *          RF_StatCmdDoneError         - Command was rejected by the RF core.
 *          RF_StatRadioInactiveError   - The RF core is OFF.
 */
static RF_Stat executeDirectImmediateCmd(uint32_t pCmd, uint32_t* rawStatus)
{
    /* If the RF core is ON, we can send the command */
    if (bRadioIsActive)
    {
        /* Submit the command to the doorbell */
        uint32_t localStatus = RFCDoorbellSendTo(pCmd);

        /* Pass the rawStatus to the callee if possible. */
        if(rawStatus)
        {
            *rawStatus = localStatus;
        }

        /* Check the return value of the RF core through the CMDSTA register within the doorbell */
        if ((localStatus & RF_CMDSTA_REG_VAL_MASK) == CMDSTA_Done)
        {
            /* The command was accepted */
            return RF_StatCmdDoneSuccess;
        }
        else
        {
            /* The command was rejected */
            return RF_StatCmdDoneError;
        }
    }
    else
    {
        /* The RF core is not capable of receiving the command */
        return RF_StatRadioInactiveError;
    }
}

/*
 *  Send a direct or immediate command to the RF core. The command is rejected
 *  if the RF core is configured to a different PHY (client).
 *
 *  Input:  h                           - Handle to the client calling this function.
 *          pCmd                        - Pointer to the command which shall be sent to the RF core.
 *          rawStatus                   - Return address of raw status byte read from CMDSTA register.
 *  Return: RF_StatCmdDoneSuccess       - If the command was sent and accepted by the RF core.
 *          RF_StatCmdDoneError         - Command was rejected by the RF core.
 *          RF_StatInvalidParamsError   - Client do not have the right to send commands now.
 *          RF_StatRadioInactiveError   - The RF core is OFF.
 */
static RF_Stat runDirectImmediateCmd(RF_Handle h, uint32_t pCmd, uint32_t* rawStatus)
{
    /* Local variable. */
    RF_Stat status;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Only the current client is allowed to send direct commands */
    if (h != pCurrClient)
    {
        /* Return with an error code it is a different client */
        status = RF_StatInvalidParamsError;
    }
    else
    {
        /* Execute the direct or immediate command. */
        status = executeDirectImmediateCmd(pCmd, rawStatus);
    }

    /* Exit critical section. */
    HwiP_restore(key);

    /* Return with the status information about the success of command execution. */
    return status;
}

/*-------------- API functions ---------------*/

/*
 * ======== RF_open ========
 * Open an RF handle
 */
RF_Handle RF_open(RF_Object *pObj, RF_Mode *pRfMode, RF_RadioSetup *pOpSetup, RF_Params *params)
{
    /* Assert */
    DebugP_assert(pObj != NULL);

    /* Read available RF modes from the PRCM register */
    uint32_t availableRfModes = HWREG(PRCM_BASE + PRCM_O_RFCMODEHWOPT);

    /* Verify that the provided configuration is supported by this device.
       Reject any request which is not compliant. */
    if (pRfMode && pOpSetup && (availableRfModes & (1 << pRfMode->rfMode)))
    {
        /* Trim the override list; The implementation of RFCOverrideUpdate is device specific */
        RFCOverrideUpdate((RF_Op*)pOpSetup, NULL);

        /* Register the (valid) RF mode to the client */
        pObj->clientConfig.pRfMode = pRfMode;

        /* Register the setup command to the client */
        pObj->clientConfig.pOpSetup = pOpSetup;
    }
    else
    {
        /* Return with null if the device do not support the requested configuration */
        return NULL;
    }

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Check whether RF driver is accepting more clients */
    if (nClients < N_MAX_CLIENTS)
    {
        /* Initialize shared objects on first client */
        if (nClients == 0) rf_init();

        /* Register the new client */
        nClients++;

        /* Restore the key */
        HwiP_restore(key);

        /* Populate default params if not provided */
        RF_Params rfParams;
        if (params == NULL)
        {
            RF_Params_init(&rfParams);
            params = &rfParams;
        }

        /* Initialize RF_Object config */
        pObj->clientConfig.nInactivityTimeout     = params->nInactivityTimeout;
        pObj->clientConfig.nPowerUpDuration       = params->nPowerUpDuration;
        pObj->clientConfig.bPowerUpXOSC           = params->bPowerUpXOSC;
        pObj->clientConfig.bUpdateSetup           = true;
        pObj->clientConfig.nPowerUpDurationMargin = params->nPowerUpDurationMargin;

        /* Set all the callbacks to default (do nothing)*/
        pObj->clientConfig.pErrCb                 = (void*) defaultCallback;
        pObj->clientConfig.pPowerCb               = (void*) defaultCallback;

        /* If a user specified callback is provided, overwrite the default */
        if (params->pErrCb)
        {
            pObj->clientConfig.pErrCb = (void *)params->pErrCb;
        }
        if (params->pPowerCb)
        {
            pObj->clientConfig.pPowerCb = (void *)params->pPowerCb;
        }

        /* Initialize client state & variables */
        memset((void*)&pObj->state, 0, sizeof(pObj->state));

        /* Initialize client semaphore and clock object */
        SemaphoreP_constructBinary(&pObj->state.semSync, 0);

        /* Initialize client specifi objects */
        ClockP_Params cp;
        ClockP_Params_init(&cp);
        cp.arg = (uintptr_t)pObj;
        ClockP_construct(&pObj->state.clkInactivity,    /* Clock object */
                         (ClockP_Fxn)clkInactivityFxn,  /* Clock function */
                         0,                             /* Clock timeout */
                         &cp);                          /* Clock parameters */

        /* Return with and RF handle (RF_Obj*) */
        return pObj;
    }
    else
    {
        /* Restore the key and return if the new client request can not be served */
        HwiP_restore(key);

        /* Return with null if no more clients are accepted */
        return NULL;
    }
}

/*
 * ======== RF_close ========
 * Close an RF handle
 */
void RF_close(RF_Handle h)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Wait for all issued commands to finish */
    if(nClients)
    {
        if (cmdQ.nSeqPost != cmdQ.nSeqDone)
        {
            /* Trace the end of pending queue for client h */
            RF_Cmd *pCmd = Q_end(h, &cmdQ.pPend);

            /* If the queue is empty, but there is a running command */
            if ((!pCmd) && (cmdQ.pCurrCmd))
            {
                /* Current command is the last command */
                pCmd = cmdQ.pCurrCmd;
            }

            /* Pend until the running command terminates */
            if (pCmd)
            {
                RF_pendCmd(h, pCmd->ch, (RF_EventCmdAborted | RF_EventCmdStopped | RF_EventCmdCancelled));
            }
        }

        /* Enter critical section */
        uint32_t key = HwiP_disable();

        /* Check weather this is the last client */
        if (--nClients == 0)
        {
            if (bRadioIsActive)
            {
                /* Release the constraint on the RF resources */
                rfReleaseConstraint(RF_PowerConstraintCmdQ);

                /* Exit critical section */
                HwiP_restore(key);

                /* Wait until the radio is powered down (outside critical section) */
                SemaphoreP_pend(&h->state.semSync, SemaphoreP_WAIT_FOREVER);

                /* Enter critical section */
                key = HwiP_disable();
            }

            /* Unregister shared RTOS objects */
            SwiP_destruct(&swiFsm);
            HwiP_destruct(&hwiCpe0);
            SwiP_destruct(&swiHw);
            HwiP_destruct(&hwiHw);
            ClockP_destruct(&clkPowerUp);

            /* Unregister the wakeup notify callback */
            Power_unregisterNotify(&RF_wakeupNotifyObj);

            /* Release XOSC_HF dependency if it was set by this client */
            if (h->clientConfig.bPowerUpXOSC == true)
            {
                Power_releaseDependency(PowerCC26XX_XOSC_HF);
            }
        }

        /* If we're the current RF client, stop being it */
        if (pCurrClient == h)
        {
            pCurrClient = NULL;
        }

        /* Exit critical section */
        HwiP_restore(key);

        /* Unregister client specific RTOS objects (these are not shared between clients) */
        SemaphoreP_destruct(&h->state.semSync);
        ClockP_destruct(&h->state.clkInactivity);
    }
}

/*
 * ======== RF_getCurrentTime ========
 * Get current time in RAT ticks
 */
uint32_t RF_getCurrentTime(void)
{
    /* Local variable */
    uint64_t nCurrentTime = 0;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* If radio is active, read the RAT */
    if (bRadioIsActive)
    {
        /* Read the RAT timer through register access */
        nCurrentTime = HWREG(RFC_RAT_BASE + RFC_RAT_O_RATCNT);

        /* Exit critical section */
        HwiP_restore(key);
    }
    else
    {
        /* Exit critical section */
        HwiP_restore(key);

        /* The radio is inactive, read the RTC instead */
        nCurrentTime  = AONRTCCurrent64BitValueGet();

        /* Conservatively assume that we are just about to increment the RTC
           Scale with the 4 MHz that the RAT is running
           Add the RAT offset for RTC==0 */
        nCurrentTime += RF_RTC_TICK_INC;
        nCurrentTime *= RF_SCALE_RTC_TO_4MHZ;
        nCurrentTime += ((uint64_t)ratCmd.start.rat0) << RF_SHIFT_32_BITS;
        nCurrentTime >>= RF_SHIFT_32_BITS;
    }

    /* Return with the current value */
    return (uint32_t) nCurrentTime;
}

/*
 * ======== RF_postCmd ========
 * Post radio command
 */
RF_CmdHandle RF_postCmd(RF_Handle h, RF_Op* pOp, RF_Priority ePri, RF_Callback pCb, RF_EventMask bmEvent)
{
    /* Assert */
    DebugP_assert(h   != NULL);
    DebugP_assert(pOp != NULL);

    /* Get hold of an RF command container (within critical section) */
    bool    bHeadPos;
    RF_Cmd* pCmd;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Try to allocate container */
    pCmd = allocCmd();

    /* If allocation failed */
    if (pCmd == NULL)
    {
        /* Exit critical section */
        HwiP_restore(key);

        /* No more RF command containers available -> set status and return error code */
        return (RF_CmdHandle)RF_ALLOC_ERROR;
    }

    /* Stop inactivity clock if running */
    ClockP_stop(&h->state.clkInactivity);

    /* Increment the sequence number and mask the value */
    cmdQ.nSeqPost = (cmdQ.nSeqPost + 1) & N_CMD_MODMASK;

    /* Populate RF_Op container */
    pCmd->pOp       = pOp;
    pCmd->ePri      = ePri;
    pCmd->pCb       = pCb;
    pCmd->ch        = cmdQ.nSeqPost;
    pCmd->pClient   = h;
    pCmd->bmEvent   = bmEvent & ~RF_INTERNAL_IFG_MASK;
    pCmd->flags     = 0;
    pCmd->pastifg   = 0;

    /* Submit to pending command queue */
    if (Q_push(&cmdQ.pPend, pCmd, &bHeadPos))
    {
        /* Store the sequence number for the client */
        h->state.chLastPosted = pCmd->ch;

        /* Cancel ongoing yielding */
        if (h->state.bYielded == true)
        {
            h->state.bYielded    = false;
            bRatSyncWasRequested = false;
        }

        /* Mark the command that it is allocated */
        pCmd->flags |= RF_CMD_ALLOC_FLAG;

        /* If this is the first entry in the queue*/
        if(bHeadPos == true)
        {
            /* Cancel any previous request of powering down the radio */
            if (bRadioYieldingWasRequested && bRadioIsActive)
            {
                bRadioYieldWasCancelled    = true;
                bRadioYieldingWasRequested = false;
                bRatSyncWasRequested       = false;
            }
        }

        /* Exit critical section */
        HwiP_restore(key);

        /* Trigger dispatcher HWI if there is no running command */
        if (bHeadPos)
        {
            triggDispatcher();
        }

        /* Return with the command handle as success */
        return pCmd->ch;
    }
    else
    {
        /* Exit critical section */
        HwiP_restore(key);

        /* Return with an error code */
        return (RF_CmdHandle)RF_ALLOC_ERROR;
    }
}

/*
 * ======== RF_pendCmd ========
 * Pend on radio command
 */
RF_EventMask RF_pendCmd(RF_Handle h, RF_CmdHandle ch, RF_EventMask bmEvent)
{
    /* Assert */
    DebugP_assert(h  != NULL);

    /* If the command handle is invalid (i.e. RF_ALLOC_ERROR) */
    if(ch < 0)
    {
      /* Return with zero means the command was rejected earlier */
      return 0;
    }

    /* Enter critical section */
    uint32_t key = SwiP_disable();

    /* Find the command based on its handle in the command pool */
    RF_Cmd* pCmd = getCmd(ch, RF_CMD_ALLOC_FLAG);

    /* If the command was already disposed */
    if (!pCmd || !(pCmd->flags & RF_CMD_ALLOC_FLAG))
    {
        /* Exit critical section */
        SwiP_restore(key);

        /* Return with last command done event */
        return RF_EventLastCmdDone;
    }

    /* If the command still exist, but was cancelled */
    if (pCmd->flags & (RF_CMD_ABORTED_FLAG | RF_CMD_STOPPED_FLAG | RF_CMD_CANCELLED_FLAG))
    {
        /* Exit critical section */
        SwiP_restore(key);

        /* Wait until the command is being disposed by the radioOpDone method */
        while(pCmd->flags & (RF_CMD_ABORTED_FLAG | RF_CMD_STOPPED_FLAG | RF_CMD_CANCELLED_FLAG));

        /* Return with last command done */
        return RF_EventLastCmdDone;
    }

    /* Expand the pend mask to accept RF_EventLastCmdDone and RF_EventLastFGCmdDone events even if it is not given explicitely */
    bmEvent = (bmEvent | RF_EventLastCmdDone);

    /* If the command is being executed, but the event we pending on has already happend (i.e. in a chain),
       return the past events */
    if(pCmd->pastifg & bmEvent)
    {
        /* Exit critical section */
        SwiP_restore(key);

        /* Store the cause of returning */
        h->state.unpendCause = pCmd->pastifg & bmEvent;

        /* Clear the handled past events so it is possible to pend again */
        pCmd->pastifg &= ~h->state.unpendCause;

        /* Return with the events */
        return h->state.unpendCause;
    }

    /* Command has still not finished, override user callback with one that calls the user callback then posts to semaphore */
    if (pCmd->pCb != syncCb)
    {
        /* Temporarily store the callback function */
        h->state.pCbSync = (void*)pCmd->pCb;

        /* Exhange the callback funtion: this will invoke the user callback and post to the semaphore if needed */
        pCmd->pCb = syncCb;
    }

    /* Store the event subscriptions in the clients context. This can only be one of the already enabled
       interrupt sources by RF_postCmd (including RF_EventLastCmdDone) */
    h->state.eventSync = bmEvent;

    /* Exit critical section */
    SwiP_restore(key);

    /* Wait for semaphore */
    SemaphoreP_pend(&h->state.semSync, SemaphoreP_WAIT_FOREVER);

    /* Return the events that resulted in releasing the RF_pend() call */
    return h->state.unpendCause;
}

/*
 *  ======== RF_runCmd ========
 *  Run to completion a posted command
 */
RF_EventMask RF_runCmd(RF_Handle h, RF_Op* pOp, RF_Priority ePri, RF_Callback pCb, RF_EventMask bmEvent)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* If no user callback was provided, use the one which posts to the semaphore */
    if (pCb == NULL)
    {
        pCb = syncCb;
    }

    /* Post the requested command */
    RF_CmdHandle ch = RF_postCmd(h, pOp, ePri, pCb, bmEvent);

    /* If the command was accepted, pend until one of the special events occur */
    return RF_pendCmd(h, ch, (RF_EventCmdAborted | RF_EventCmdStopped | RF_EventCmdCancelled));
}

/*
 *  ======== RF_yieldCmd ========
 *  Release client access
 */
void RF_yield(RF_Handle h)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Set flag to re-initalize the available RAT channels
       Limitation : assumes that any currently running RAT activity will be ignored to start power-down */
    bRatSyncWasRequested = true;

    /* Check for nSeqDone overflow */
    if ((cmdQ.nSeqPost - h->state.chLastPosted) < 0)
    {
        if((h->state.chLastPosted <= cmdQ.nSeqDone) || (cmdQ.nSeqPost >= cmdQ.nSeqDone))
        {
            /* All commands are done. Stop inactivity timer. */
            ClockP_stop(&h->state.clkInactivity);

            /* Decrement the active client counter. This will also initiate power
               down if possible. */
            rfReleaseConstraint(RF_PowerConstraintCmdQ);

            /* Indicate that the client requested yielding. */
            if (bRadioIsActive)
            {
                bRadioYieldingWasRequested = true;
            }

            /* Exit critical section */
            HwiP_restore(key);
            return;
        }
    }
    else
    {
        if(h->state.chLastPosted == cmdQ.nSeqDone)
        {
            /* All commands are done. Stop inactivity timer. */
            ClockP_stop(&h->state.clkInactivity);

            /* Decrement the active client counter. This will also initiate power
               down if possible. */
            rfReleaseConstraint(RF_PowerConstraintCmdQ);

            /* Indicate that the client requested yielding. */
            if (bRadioIsActive)
            {
                bRadioYieldingWasRequested = true;
            }

            /* Exit critical section */
            HwiP_restore(key);
            return;
        }
    }

    /* There are still client commands that haven't finished
       -> set flag to indicate immediate powerdown when last command is done */
    h->state.bYielded = true;

    /* Exit critical section */
    HwiP_restore(key);
}

/*
 *  ======== RF_cancelCmd ========
 *  Cancel single radio command
 */
RF_Stat RF_cancelCmd(RF_Handle h, RF_CmdHandle ch, uint8_t mode)
{
    /* Assert  */
    DebugP_assert(h != NULL);

    /* Invoke the aborting process with the input arguments on a single command */
    return abortCmd(h, ch, mode);
}

/*
 *  ======== RF_flushCmd ========
 *  Cancel multiple radio commands from a client
 */
RF_Stat RF_flushCmd(RF_Handle h, RF_CmdHandle ch, uint8_t mode)
{
    /* Assert  */
    DebugP_assert(h != NULL);

    /* Abort multiple radio commands implicitly */
    return (abortCmd(h, ch, (mode | RF_ABORT_CANCEL_MULTIPLE_CMD)));
}

/*
 *  ======== RF_Params_init ========
 *  Initialize the RF_params to default value
 */
void RF_Params_init(RF_Params *params)
{
    /* Assert */
    DebugP_assert(params != NULL);

    /* Assign default values for RF_params */
    *params = RF_defaultParams;
}

/*
 *  ======== RF_runImmediateCmd ========
 *  Run immediate command
 */
RF_Stat RF_runImmediateCmd(RF_Handle h, uint32_t* pCmd)
{
    /* Assert  */
    DebugP_assert(h != NULL);

    /* Submit the command to the RF core */
    return runDirectImmediateCmd(h, (uint32_t)pCmd, NULL);
}

/*
 *  ======== RF_runDirectCmd ========
 *  Run direct command
 */
RF_Stat RF_runDirectCmd(RF_Handle h, uint32_t cmd)
{
    /* Assert  */
    DebugP_assert(h != NULL);

    /* Submit the command to the RF core */
    return runDirectImmediateCmd(h, cmd, NULL);
}

/*
 *  ======== RF_getRssi ========
 *  Get RSSI value
 */
int8_t RF_getRssi(RF_Handle h)
{
    /* Assert  */
    DebugP_assert(h != NULL);

    /* Local variable. */
    uint32_t rawRssi;

    /* Read the RSSI value if possible. */
    RF_Stat status = runDirectImmediateCmd(h, CMDR_DIR_CMD(CMD_GET_RSSI), &rawRssi);

    /* Decode the RSSI value if possible. */
    if(status == RF_StatCmdDoneSuccess)
    {
        return (int8_t)((rawRssi >> RF_SHIFT_16_BITS) & RF_CMDSTA_REG_VAL_MASK);
    }
    else
    {
        return (int8_t)RF_GET_RSSI_ERROR_VAL;
    }
}

/*
 *  ======== RF_getInfo ========
 *  Get RF driver info
 */
RF_Stat RF_getInfo(RF_Handle h, RF_InfoType type, RF_InfoVal *pValue)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Prepare the default status value */
    RF_Stat status = RF_StatSuccess;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Serve the different flavor of requests */
    switch(type)
    {
        case RF_GET_CURR_CMD:
            /* Get the handle of the currently running command. It can be conerted
               to a pointer through the RF_getCmdOp() API. */
            if (cmdQ.pCurrCmd)
            {
                pValue->ch = cmdQ.pCurrCmd->ch;
            }
            else
            {
                status = RF_StatError;
            }
            break;

        case RF_GET_AVAIL_RAT_CH:
            /* Get available RAT channels through the direct command if available.
               These channels can be allocated and used by the application. */
            if (bRatSyncWasRequested == false)
            {
                pValue->availRatCh = ratModule.availRatCh;
            }
            else
            {
                status = RF_StatError;
            }
            break;

        case RF_GET_RADIO_STATE:
            /* Get current radio state */
            pValue->bRadioState = bRadioIsActive;
            break;

        default:
            status = RF_StatInvalidParamsError;
            break;
    }

    /* Exit critical section */
    HwiP_restore(key);

    /* Return with a status code */
    return status;
}

/*
 *  ======== RF_getCmdOp ========
 *  Get RF command
 */
RF_Op* RF_getCmdOp(RF_Handle h, RF_CmdHandle ch)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Find the command based on its handle */
    RF_Cmd* pCmd = getCmd(ch, RF_CMD_ALLOC_FLAG);

    /* If the command exists, return with a pointer to its radio operation.
       Otherwise, return a null pointer */
    if (pCmd)
    {
        return (pCmd->pOp);
    }
    else
    {
        return NULL;
    }
}

/*
 *  ======== RF_ratCompare ========
 *  Set RAT compare
 */
RF_RatHandle RF_ratCompare(RF_Handle h, rfc_CMD_SET_RAT_CMP_t* pCmd, uint32_t compareTime, RF_Callback pCb)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Configure the RAT channel into COMPARE mode. */
    return ratSetupChannel(h, pCb, pCmd, compareTime, 0, RF_RatModeCompare);
}

/*
 *  ======== RF_ratCapture ========
 *  Set RAT capture
 */
RF_RatHandle RF_ratCapture(RF_Handle h, uint16_t config, RF_Callback pCb)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Configure the RAT channel into CAPTURE mode. */
    return ratSetupChannel(h, pCb, NULL, 0, config, RF_RatModeCapture);
}

/*
 *  ======== RF_ratHwOutput ========
 *  Set RAT HW output
 */
RF_Stat RF_ratHwOutput(RF_Handle h, uint16_t config)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Post a direct command to set up GPIO to be a RAT signal*/
    return runDirectImmediateCmd(h, ((uint32_t)CMDR_DIR_CMD_2BYTE(CMD_SET_RAT_OUTPUT, config)), NULL);
}

/*
 *  ======== RF_ratDisableChannel ========
 *  Disable RAT channel
 */
RF_Stat RF_ratDisableChannel(RF_Handle h, RF_RatHandle ratHandle)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Default return value */
    RF_Stat status = RF_StatError;

    /* Enter critical section. */
    uint32_t key = HwiP_disable();

    /* Find the pointer to the RAT channel configuration. */
    RAT_Channel* ratCh = ratGetChannel(ratHandle);

    if(ratCh)
    {
        /* If the RF core is active, abort the RAT event. */
        if(bRadioIsActive)
        {
            /* Calculate the configuration field of command (the channel we disable). */
            uint16_t config = (RF_RAT_CH_LOWEST + ratCh->handle) << RF_SHIFT_8_BITS;

            /* Disable the channel within the RF core. */
            status = runDirectImmediateCmd(h, ((uint32_t)CMDR_DIR_CMD_2BYTE(CMD_DISABLE_RAT_CH, config)), NULL);

            /* Free the container for further use. We do it after the direct command to be sure it is not powered down.
               This will implicitely schedule the next event and run the power management accordingly. */
            ratFreeChannel(ratCh);
        }
        else
        {
            /* Set status to be successfull */
            status = RF_StatSuccess;

            /* Free the container for further use. */
            ratFreeChannel(ratCh);

            /* Recalculate the next wakeup event. */
            dispatchNextEvent();
        }
    }

    /* Exit critical section. */
    HwiP_restore(key);

    /* Return with the status code */
    return status;
}

/*
 *  ======== RF_control ========
 *  RF control
 */
RF_Stat RF_control(RF_Handle h, int8_t ctrl, void *args)
{
    /* Assert */
    DebugP_assert(h != NULL);

    /* Prepare the return value for worst case scenario */
    RF_Stat status = RF_StatError;

    /* Enter critical section */
    uint32_t key = HwiP_disable();

    /* Serve the different requests */
    switch (ctrl)
    {
        case RF_CTRL_SET_INACTIVITY_TIMEOUT:
            /* Update the inactivity timeout of the client.
               This can be used if the value given at RF_open
               need to be updated */
            h->clientConfig.nInactivityTimeout = *(uint32_t *)args;
            status = RF_StatSuccess;
            break;

        case RF_CTRL_UPDATE_SETUP_CMD:
            /* Enable a special boot process which can be controlled
               through the config field of the radio setup command.
               This will influence only the next power up sequence
               and will be reset automatically afterwards. The special
               power up process will require longer power up time, hence
               the nPowerUpDuration need to be increased */
            h->clientConfig.bUpdateSetup = true;
            h->clientConfig.nPowerUpDuration += RF_ANALOG_CFG_TIME_US;
            status = RF_StatSuccess;
            break;

        case RF_CTRL_SET_POWERUP_DURATION_MARGIN:
            /* Configure the margin which is added to the measured
               nPowerUpDuration. This can ensure that the commands
               are executed on time, depending on the load of the
               cpu */
            h->clientConfig.nPowerUpDurationMargin = *(uint32_t *)args;
            status = RF_StatSuccess;
            break;

        case RF_CTRL_SET_HWI_PRIORITY:
            /* Changing priorities during run-time has constraints.
               To not mess up with the RF driver, we require the RF
               driver to be inactive. */
            if (bRadioIsBeingPoweredUp   || bRadioIsActive ||
                bRadioIsBeingPoweredDown || (Q_peek(&cmdQ.pPend)))
            {
                status = RF_StatBusyError;
            }
            else
            {
                HwiP_setPriority(INT_RFC_CPE_0,   *(uint32_t *)args);
                HwiP_setPriority(INT_RFC_HW_COMB, *(uint32_t *)args);

                status = RF_StatSuccess;
            }
            break;

        case RF_CTRL_SET_SWI_PRIORITY:
            /* Changing priorities during run-time has constraints.
               To not mess up with the RF driver, we require the RF
               driver to be inactive. */
            if (bRadioIsBeingPoweredUp   || bRadioIsActive ||
                bRadioIsBeingPoweredDown || (Q_peek(&cmdQ.pPend)))
            {
                status = RF_StatBusyError;
            }
            else
            {
                SwiP_setPriority(&swiFsm, *(uint32_t *)args);
                SwiP_setPriority(&swiHw,  *(uint32_t *)args);

                status = RF_StatSuccess;
            }
            break;

        default:
            /* Request can not be served */
            status = RF_StatInvalidParamsError;
            break;
    }

    /* Exit critical section */
    HwiP_restore(key);

    /* Return with the status code */
    return status;
}
